/*
USAGE

Metaprogram. We generate libc foreign declarations compatible with an explicitly-requested
glibc version. Update TARGET_GLIBC_VERSION in this file and then:

$ jai generate_glibc_bindings.jai

MOTIVATION

One of the frustations of shipping binary software on GNU+Linux is versioned symbols.
In order to maintain compatibility with older software, the GNU project have employed
a symbol versioning scheme that allows software to use the version of a specific function
as it was when the software was originally compiled and linked. This ensures that changes
in any particular function or to the ABI do not cause older software to break. This
introduces a backward compatibility issue where if software is compiled on a machine
with GLIBC 2.27, it cannot, in many circumstances, run on machines that only have GLIBC
2.15 available.

This metaprogram takes advantage of the jai compiler's ability to specify versioned symbols
at the #foreign function's declaration site in order to enable targeting older versions
of GLIBC on a machine running relatively new versions.

HOW IT WORKS

The accompanying file (libc_bindings.jai) contains a set of unversioned declarations;
they are loaded by POSIX.jai by default. This metaprogram will compile the entire POSIX
module, look for declarations in libc_bindings.jai, find the appropriate versioned-
symbol for that declaration and the specified target glibc version, then write an
identical binding out to a file with the symbol information.

Note that if a function was not introduced until after the target glibc version, it may be omitted from the output.
*/

// Specifies the version of glibc to target when looking symbols. The most recent version of a symbol
// that exists prior or in the target version will be chosen for the output.
TARGET_GLIBC_VERSION :: "2.17";

// If a function is not implemented for the target glibc version or prior, it will be omitted; otherwise,
// "@GLIBC_NOT_AVAILABLE_BEFORE_<VERSION>" will be added to the symbol name.
omit_unavailable_functions := true;

#import "Basic";
#import "String";
#import "Compiler";
#import "File";
#import "POSIX";

system_max_version_major := 0;
system_max_version_minor := 0;
system_max_version_mini  := 0;

target_version_major := 0;
target_version_minor := 0;
target_version_mini  := 0;

glibc_min_version_major := 2;
glibc_min_version_minor := 2;
glibc_min_version_mini  := 5;

libc_handle: *void;
libpt_handle: *void;
librt_handle: *void;

parse_version :: (_remainder: string) -> major: int, minor: int, mini: int {
	// quick and dirty target version parsing
	remainder := _remainder;
	success: bool = false;
	major: int;
	minor: int;
	mini:  int;

	major, success, remainder = string_to_int(remainder);
	assert(success);
	if remainder {
		assert(remainder[0] == #char ".");
		advance(*remainder, 1);
		minor, success, remainder = string_to_int(remainder);
		assert(success);
	}

	if remainder {
		assert(remainder[0] == #char ".");
		advance(*remainder, 1);
		mini, success, remainder = string_to_int(remainder);
		assert(success);
	}

	return major, minor, mini;
}

#run generate_bindings();

generate_bindings :: () {
	opts := get_build_options();
	opts.output_type = .NO_OUTPUT;
	set_build_options(opts);

	libc_handle = dlopen("libc.so.6", RTLD_LAZY | RTLD_GLOBAL);
	assert(libc_handle != null, "libc could not be loaded!");
	print("libc.so.6 loaded to address: %\n", libc_handle);

	libpt_handle = dlopen("libpthread.so.0", RTLD_LAZY | RTLD_GLOBAL);
	assert(libpt_handle != null, "libpthread could not be loaded!");
	print("libpthread.so.0 loaded to address: %\n", libpt_handle);

	librt_handle = dlopen("librt.so.1", RTLD_LAZY | RTLD_GLOBAL);
	assert(librt_handle != null, "librt could not be loaded!");
	print("librt.so.1 loaded to address: %\n", librt_handle);


	target_version_major, target_version_minor, target_version_mini = parse_version(TARGET_GLIBC_VERSION);
	print("Target glibc version: %.%.%\n", target_version_major, target_version_minor, target_version_mini);

	gnu_get_libc_version := cast(#type () -> *u8 #foreign) dlsym(libc_handle, "gnu_get_libc_version");
	system_max_version_major, system_max_version_minor, system_max_version_mini = parse_version(to_string(gnu_get_libc_version()));

	print("System glibc version: %.%.%\n", system_max_version_major, system_max_version_minor, system_max_version_mini);


	{
		ws := compiler_create_workspace();
		set_build_options(opts, ws);
		compiler_begin_intercept(ws);

		add_build_string("#import \"POSIX\";", ws);

		filename := sprint("libc_bindings_%.jai", TARGET_GLIBC_VERSION);
		generate_bindings_file(ws, filename);
		free(filename);

		compiler_end_intercept(ws);
	}
}

generate_bindings_file :: (ws: Workspace, filename: string) {
	libc_builder: String_Builder;

	print_to_builder(*libc_builder, "// This file generated by generate_glibc_bindings.jai for GLIBC %.%", target_version_major, target_version_minor);
	if target_version_mini then print_to_builder(*libc_builder, ".%", target_version_mini);
	append(*libc_builder, "\n\n");

	while true {
        using Message.Kind;

        message := compiler_wait_for_message();
        if message.kind == COMPLETE break;

        build_steps(*libc_builder, message);
    }

LIBC_DECL_STRING :: #string DONE
#scope_file
libc :: #system_library "libc";
librt :: #system_library "librt";
pthreads :: #system_library "libpthread";
#if OS_LINUX && GNU_ENV {
    libexecinfo :: #system_library "libexecinfo";
} else {
    libexecinfo :: libc;
}
DONE

    append(*libc_builder, LIBC_DECL_STRING);


	file := file_open(filename, for_writing=true);
    file_write(*file, builder_to_string(*libc_builder));
    file_close(*file);
}

build_steps :: (libc_builder: *String_Builder, message : *Message) {
    using Message.Kind;

    if message.kind == TYPECHECKED {
        tc := cast(*Message_Typechecked) message;

        for decl : tc.declarations {
            if !decl.root_expression continue;
            if (decl.flags & decl.ALREADY_MODIFIED) continue;

            if decl.root_expression.kind == .PROCEDURE_HEADER {
                if !decl.name then continue;  // This is a dummy declaration for a header, but we want the one corresponding to the bound name.
                header := cast(*Code_Procedure_Header) decl.root_expression;
                if header.procedure_flags & (PROCEDURE_IS_COMPILE_TIME | PROCEDURE_IS_POLYMORPHIC) continue;

                FOREIGN_FLAGS :: (PROCEDURE_IS_ELSEWHERE | PROCEDURE_IS_C_CALL);
                if (header.procedure_flags & FOREIGN_FLAGS) == FOREIGN_FLAGS && contains(decl.filename, "_bindings.jai") {
                	proc_type := cast(*Type_Info_Procedure) decl.type;
                	write_jai_header_in_c(libc_builder, proc_type, decl, false);
                }

            }
        }
    } else if message.kind == .PHASE {
        phase_message := cast(*Message_Compilation_Phase) message;
        phase := phase_message.phase;
    }
}

write_jai_header_in_c :: (libc_builder: *String_Builder, proc_type: *Type_Info_Procedure, decl: *Code_Declaration, is_func_ptr := false) -> bool {
	if !decl.root_expression return true;
    if !decl.name return true;

	proc := cast(*Code_Procedure_Header) decl.root_expression;
	// print("KIND: %\n", decl.root_expression.kind);

	bake_args: [] Code_Argument;

	if decl.root_expression.kind == Code_Node.Kind.DIRECTIVE_BAKE {
		bake := cast(*Code_Directive_Bake) decl.root_expression;
		assert(bake.bake_type == bake.Bake_Type.PARAMETER_VALUE_BAKE);

		bake_args = bake.arguments_unsorted;

		decl = bake.procedure_ident.resolved_declaration;
		proc = cast(*Code_Procedure_Header) decl.root_expression;
	}

    assert(proc != null);

    if proc.kind == Code_Node.Kind.IDENT {
        ident := cast(*Code_Ident) proc;
        print_to_builder(libc_builder, "% :: %;\n\n", decl.name, ident.name);
        return true;
    }
    assert(proc.kind == Code_Node.Kind.PROCEDURE_HEADER);

    is_elsewhere := (proc.procedure_flags & PROCEDURE_IS_ELSEWHERE) != 0;
    // is_compile_time := (proc.procedure_flags & PROCEDURE_IS_COMPILE_TIME) != 0;
    is_c_call := (proc.procedure_flags & PROCEDURE_IS_C_CALL) != 0;
	if !is_elsewhere && !(decl.flags & decl.PROGRAM_EXPORT) return true;

    write_foreign_prototypes := true;
    if !write_foreign_prototypes return true;

    // earliest version of the function available if the function is more recent than the target version,
	// otherwise, latest version available that is still <= than the target version.
	closest_major := 99;
	closest_minor := 99;
	closest_mini  := 99;
	target_library_name := "__INVALID";
    if is_elsewhere && is_c_call {
		major := system_max_version_major;
		minor := system_max_version_minor;
		mini  := system_max_version_mini;

		symbol_name := proc.name;
		if proc.foreign_function_name then symbol_name = proc.foreign_function_name;

		c_symbol_name := to_c_string(symbol_name);

		lib_handle := null;
		// Figure out which of the libc libraries the base-symbol originates from; again because Code_Procedure_Header doesnt expose this for us.
		// @TODO Additionally, sometimes new versions of symbols exist in different libraries altogether. clock_gettime@GLIBC_2.2.5 exists only in librt.so.1, but
		// clock_gettime@GLIBC_2.17 exists only in libc.so.6. We should probably detect this and check each library for the most preferrable symbol for the target
		// version.
		if  dlsym(libc_handle, c_symbol_name) {
			target_library_name = "libc";
			lib_handle = libc_handle;
		} else if dlsym(libpt_handle, c_symbol_name) {
			target_library_name = "pthreads";
			lib_handle = libpt_handle;
		} else if dlsym(librt_handle, c_symbol_name) {
			target_library_name = "librt";
			lib_handle = librt_handle;
		}

		count := 1;
		while true {
			ver_string: string;
			if mini {
				ver_string = sprint("GLIBC_%.%.%", major, minor, mini);
			} else {
				ver_string = sprint("GLIBC_%.%", major, minor);
			}

			c_ver_string := to_c_string(ver_string);

			symbol := dlvsym(lib_handle, c_symbol_name, c_ver_string);

			if symbol {

				is_greater := closest_major > target_version_major;
				if !is_greater && closest_major == target_version_major then is_greater = closest_minor > target_version_minor;
				if !is_greater && closest_minor == target_version_minor then is_greater = closest_mini  > target_version_mini;

				if is_greater {
					closest_major = major;
					closest_minor = minor;
					closest_mini  = mini;
				}
			}

			// print("Version: %\n", ver_string);

			free(c_ver_string);
			free(ver_string);


			if major == glibc_min_version_major
				&& minor == glibc_min_version_minor
				&& mini == glibc_min_version_mini then break;

			mini -= 1;
			if mini < 0 {
				mini = 99;
				minor -= 1;
			}

			if minor < 0 {
				minor = 99;
				major -= 1;
			}

		}

		free(c_symbol_name);

		// print("Chosen: %@%.%.%\n", symbol_name, closest_major, closest_minor, closest_mini);

		is_not_available := closest_major > target_version_major;
		if !is_not_available && closest_major == target_version_major then is_not_available = closest_minor > target_version_minor;
		if !is_not_available && closest_minor == target_version_minor then is_not_available = closest_mini  > target_version_mini;

		if is_not_available && omit_unavailable_functions {
			print("WARNING: % is not available prior to GLIBC_%.%.%, omitting...\n", symbol_name, closest_major, closest_minor, closest_mini);
			return true;
		}

	}

	if !is_func_ptr then print_to_builder(libc_builder, "% :: (", decl.name);
	else 				 print_to_builder(libc_builder, "%: (", decl.name);

	// print("ARGS: %\n", proc.arguments);
	for arg_decl: proc.arguments {
		if arg_decl.flags & (Code_Declaration.AUTO_VALUE_BAKE_IS_REQUIRED | Code_Declaration.AUTO_VALUE_BAKE) {
			is_value_baked := false;
			for bake_a: bake_args {
				if bake_a.name.name == arg_decl.name {
					is_value_baked = true;
					break;
				}
			}
			if is_value_baked continue;
		}

		if it_index > 0 && it_index < proc.arguments.count append(libc_builder, ", ");

        name := arg_decl.name;
        write_decl_type_in_c(libc_builder, name, arg_decl.type);
	}

	if !is_c_call {
		if proc.arguments.count && proc.returns.count append(libc_builder, ", ");
		for ret: proc.returns {
			name := sprint(" /*%*/", ret.name);
			if name == "" {
				name = sprint(" /*unnamed_ret_%*/", it_index); // @Leak
			}
			write_decl_type_in_c(libc_builder, name, ret.type, true);
			if it_index < proc.returns.count-1 append(libc_builder, ", ");
		}
	}

	append(libc_builder, ") -> ");

	if is_c_call {
		if proc_type.return_types.count > 1 {
			compiler_report(decl.filename, decl.l0, decl.c0, "Procedure marked #c_call but has multiple return values!");
			return false;
		}

		if proc_type.return_types.count {
            write_decl_type_in_c(libc_builder, "", proc_type.return_types[0], true, true);
        } else write_type_in_c(libc_builder, null);
	} else {
		write_type_in_c(libc_builder, null); // void
	}

	if is_elsewhere && is_c_call {
		symbol_name := proc.name;
		if proc.foreign_function_name then symbol_name = proc.foreign_function_name;

		is_not_available := closest_major > target_version_major;
		if !is_not_available && closest_major == target_version_major then is_not_available = closest_minor > target_version_minor;
		if !is_not_available && closest_minor == target_version_minor then is_not_available = closest_mini  > target_version_mini;

		ver_string: string;
		if is_not_available {
			if closest_mini {
				ver_string = sprint("@GLIBC_NOT_AVAILABLE_BEFORE_%.%.%", closest_major, closest_minor, closest_mini);
			} else {
				ver_string = sprint("@GLIBC_NOT_AVAILABLE_BEFORE_%.%", closest_major, closest_minor);
			}
		} else {
			if closest_mini {
				ver_string = sprint("@GLIBC_%.%.%", closest_major, closest_minor, closest_mini);
			} else {
				ver_string = sprint("@GLIBC_%.%", closest_major, closest_minor);
			}
		}

		print_to_builder(libc_builder, " #foreign % \"%2%3\"", target_library_name, symbol_name, ver_string);
		// @TODO maybe implement a way to figure out what library a function was declared to come from. Currently Code_Node's do not expose this information.
		free(ver_string);
	}


	append(libc_builder, ";\n\n");

	return true;
}

write_decl_type_in_c :: (libc_builder: *String_Builder, name: string, type: *Type_Info, is_return := false, is_c_call := false) {
    out_name := name;
    if name == "signed" out_name = "_signed"; // @Hack

    if type.type != Type_Info_Tag.PROCEDURE && out_name != "" {
    	append(libc_builder, out_name);
    	append(libc_builder, ": ");
    }

    if (is_return && type.type == Type_Info_Tag.PROCEDURE) append(libc_builder, "void"); // @Hack
    else write_type_in_c(libc_builder, type, out_name);
}

write_type_in_c :: (libc_builder: *String_Builder, type: *Type_Info, name := "") {
	if !type {
		append(libc_builder, "void");
		return;
	}

	if type.type == {
        case .TYPE;
            append(libc_builder, "*Type_Info");
		case .INTEGER;
			integer := cast(*Type_Info_Integer) type;
			sign := integer.signed;
			size := integer.runtime_size;

			str: string;
			if size == {
				case 1; if sign str = "s8"; else str = "u8";
				case 2; if sign str = "s16"; else str = "u16";
				case 4; if sign str = "s32"; else str = "u32";
				case 8; if sign str = "s64"; else str = "u64";
				case;
					print("Runtime size: %\n", size);
					assert(false);
			}

			append(libc_builder, str);
		case .FLOAT;
			fl := cast(*Type_Info_Float) type;
			if fl.runtime_size == 8 append(libc_builder, "float64");
			else append(libc_builder, "float");
		case .BOOL;
			append(libc_builder, "bool");
		case .STRING;
			append(libc_builder, "string");
		case .POINTER;
			ptr := cast(*Type_Info_Pointer) type;
            element := ptr.pointer_to;

			append(libc_builder, "*");
			write_type_in_c(libc_builder, ptr.pointer_to);

			// @Incomplete soa_packing
		case .VOID;
			append(libc_builder, "void");
        case .STRUCT;
            struct_desc := cast(*Type_Info_Struct) type;

            if struct_desc.polymorph_source_struct {
            	print_to_builder(libc_builder, "struct { polymorpth_struct: [%] u8; } ", struct_desc.runtime_size); // @Incomplete this doesnt account for alignment
                return;
            }
            name := struct_desc.name;

            if name == "" {
                // @Cutnpaste from write_jai_struct_in_c
                append(libc_builder, " {\n");
                indent := "    ";

                num_non_const_members := 0;
                for struct_desc.members {
                    if (it.flags & it.IMPORTED) continue;
                    if (it.flags & it.CONSTANT) continue;
                    if it.type.type == .VOID continue;
                    num_non_const_members += 1;
                    append(libc_builder, indent);
                    write_decl_type_in_c(libc_builder, it.name, it.type);
                    append(libc_builder, ";\n");
                }

                // @Hack since empty structs arent allowed it C
                if num_non_const_members == 0 {
                    append(libc_builder, indent);
                    append(libc_builder, "void *__empty_struct;");
                }


                append(libc_builder, "} ");
            } else {
                append(libc_builder, name);
            }
        case .PROCEDURE;
            write_jai_function_header_in_c(libc_builder, cast(*Type_Info_Procedure) type, name, true);
            // file_write(libc_builder, "void *");
            return; // @Hack
        case .ARRAY;
            arr := cast(*Type_Info_Array) type;

            // @Hack it doesnt seem that there's a way to distinguish ".. Any" vs "[] Any"
            // via the type-info system alone, so just use ".. Any" here because we mainly
            // only care about #foriegn functions in this code generater.
            if arr.element_type.type == .STRUCT {
            	str := cast(*Type_Info_Struct) arr.element_type;
            	if str.name == "Any" {
	            	append(libc_builder, ".. Any");
	            	return;
            	}
            }

            append(libc_builder, "[");
            if arr.array_type == {
                case arr.FIXED;
                	append(libc_builder, sprint("%", arr.array_count));

                case arr.STATIC;
                case arr.DYNAMIC;
                    append(libc_builder, "..");
            }
            append(libc_builder, "] ");
            write_type_in_c(libc_builder, arr.element_type);
        case .ENUM;
            en := cast(*Type_Info_Enum) type;
            write_type_in_c(libc_builder, en.internal_type);
		case;
			print("Unhandled type in write_type_in_c: %\n", type.type);
	}
}


unnamed_count := 0;
write_jai_function_header_in_c :: (libc_builder: *String_Builder, type: *Type_Info_Procedure, _name: string, is_func_ptr := false) {
    is_elsewhere  := (type.procedure_flags & type.IS_ELSEWHERE) != 0;
    is_c_call := (type.procedure_flags & type.IS_C_CALL) != 0;

    name := _name;
    if (name == "") {
        name = sprint("____unnamed_function_%", unnamed_count);
        unnamed_count += 1;
    }
    append(libc_builder, " ");

    append(libc_builder, name);

    if is_func_ptr {
    	append(libc_builder, ": ");
    }

    append(libc_builder, "(");

    // print("ARGS: %\n", proc.arguments);
    for arg_decl: type.argument_types {
        if it_index > 0 && it_index < type.argument_types.count append(libc_builder, ", ");

        name := sprint(" a%", it_index);
        defer free(name);
        write_decl_type_in_c(libc_builder, name, arg_decl);
    }

    append(libc_builder, ")");

    if type.return_types.count {
    	append(libc_builder, " -> (");
        for ret: type.return_types {
            name := sprint(" r%", it_index);
            defer free(name);

            write_decl_type_in_c(libc_builder, name, ret, true);
            if it_index < type.return_types.count-1 append(libc_builder, ", ");
        }

        append(libc_builder, ")");
    }

}
