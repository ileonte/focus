//
// This file was auto-generated using the following command:
//
// jai modules/POSIX/generate.jai - -android -arm64
//



RTLD_LOCAL :: 0;
RTLD_LAZY :: 0x00001;
RTLD_NOW :: 0x00002;
RTLD_NOLOAD :: 0x00004;
RTLD_GLOBAL :: 0x00100;
RTLD_NODELETE :: 0x01000;

__FD_SETSIZE :: 1024;

DT :: enum u8 {
    UNKNOWN :: 0;

    FIFO    :: 1;

    CHR     :: 2;

    DIR     :: 4;

    BLK     :: 6;

    REG     :: 8;

    LNK     :: 10;

    SOCK    :: 12;
    WHT     :: 14;
}

__DIRENT64_INO_T :: ino_t;

EPERM :: 1;
ENOENT :: 2;
ESRCH :: 3;
EINTR :: 4;
EIO :: 5;
ENXIO :: 6;
E2BIG :: 7;
ENOEXEC :: 8;
EBADF :: 9;
ECHILD :: 10;
EAGAIN :: 11;
ENOMEM :: 12;
EACCES :: 13;
EFAULT :: 14;
ENOTBLK :: 15;
EBUSY :: 16;
EEXIST :: 17;
EXDEV :: 18;
ENODEV :: 19;
ENOTDIR :: 20;
EISDIR :: 21;
EINVAL :: 22;
ENFILE :: 23;
EMFILE :: 24;
ENOTTY :: 25;
ETXTBSY :: 26;
EFBIG :: 27;
ENOSPC :: 28;
ESPIPE :: 29;
EROFS :: 30;
EMLINK :: 31;
EPIPE :: 32;
EDOM :: 33;
ERANGE :: 34;

EDEADLK :: 35;
ENAMETOOLONG :: 36;
ENOLCK :: 37;
ENOSYS :: 38;
ENOTEMPTY :: 39;
ELOOP :: 40;
EWOULDBLOCK :: EAGAIN;
ENOMSG :: 42;
EIDRM :: 43;
ECHRNG :: 44;
EL2NSYNC :: 45;
EL3HLT :: 46;
EL3RST :: 47;
ELNRNG :: 48;
EUNATCH :: 49;
ENOCSI :: 50;
EL2HLT :: 51;
EBADE :: 52;
EBADR :: 53;
EXFULL :: 54;
ENOANO :: 55;
EBADRQC :: 56;
EBADSLT :: 57;
EDEADLOCK :: EDEADLK;
EBFONT :: 59;
ENOSTR :: 60;
ENODATA :: 61;
ETIME :: 62;
ENOSR :: 63;
ENONET :: 64;
ENOPKG :: 65;
EREMOTE :: 66;
ENOLINK :: 67;
EADV :: 68;
ESRMNT :: 69;
ECOMM :: 70;
EPROTO :: 71;
EMULTIHOP :: 72;
EDOTDOT :: 73;
EBADMSG :: 74;
EOVERFLOW :: 75;
ENOTUNIQ :: 76;
EBADFD :: 77;
EREMCHG :: 78;
ELIBACC :: 79;
ELIBBAD :: 80;
ELIBSCN :: 81;
ELIBMAX :: 82;
ELIBEXEC :: 83;
EILSEQ :: 84;
ERESTART :: 85;
ESTRPIPE :: 86;
EUSERS :: 87;
ENOTSOCK :: 88;
EDESTADDRREQ :: 89;
EMSGSIZE :: 90;
EPROTOTYPE :: 91;
ENOPROTOOPT :: 92;
EPROTONOSUPPORT :: 93;
ESOCKTNOSUPPORT :: 94;
EOPNOTSUPP :: 95;
EPFNOSUPPORT :: 96;
EAFNOSUPPORT :: 97;
EADDRINUSE :: 98;
EADDRNOTAVAIL :: 99;
ENETDOWN :: 100;
ENETUNREACH :: 101;
ENETRESET :: 102;
ECONNABORTED :: 103;
ECONNRESET :: 104;
ENOBUFS :: 105;
EISCONN :: 106;
ENOTCONN :: 107;
ESHUTDOWN :: 108;
ETOOMANYREFS :: 109;
ETIMEDOUT :: 110;
ECONNREFUSED :: 111;
EHOSTDOWN :: 112;
EHOSTUNREACH :: 113;
EALREADY :: 114;
EINPROGRESS :: 115;
ESTALE :: 116;
EUCLEAN :: 117;
ENOTNAM :: 118;
ENAVAIL :: 119;
EISNAM :: 120;
EREMOTEIO :: 121;
EDQUOT :: 122;
ENOMEDIUM :: 123;
EMEDIUMTYPE :: 124;
ECANCELED :: 125;
ENOKEY :: 126;
EKEYEXPIRED :: 127;
EKEYREVOKED :: 128;
EKEYREJECTED :: 129;
EOWNERDEAD :: 130;
ENOTRECOVERABLE :: 131;
ERFKILL :: 132;
EHWPOISON :: 133;

ENOTSUP :: EOPNOTSUPP;

FNM_NOMATCH :: 1;

FNM_NOSYS :: 2;

FNM_NOESCAPE :: 0x01;

FNM_PATHNAME :: 0x02;

FNM_PERIOD :: 0x04;

FNM_LEADING_DIR :: 0x08;

FNM_CASEFOLD :: 0x10;

FNM_IGNORECASE :: FNM_CASEFOLD;

FNM_FILE_NAME :: FNM_PATHNAME;

SA_RESTORER :: 0x04000000;
MINSIGSTKSZ :: 5120;
SIGSTKSZ :: 16384;

_KERNEL__NSIG :: 64;

SIGHUP :: 1;
SIGINT :: 2;
SIGQUIT :: 3;
SIGILL :: 4;
SIGTRAP :: 5;
SIGABRT :: 6;
SIGIOT :: 6;
SIGBUS :: 7;
SIGFPE :: 8;
SIGKILL :: 9;
SIGUSR1 :: 10;
SIGSEGV :: 11;
SIGUSR2 :: 12;
SIGPIPE :: 13;
SIGALRM :: 14;
SIGTERM :: 15;
SIGSTKFLT :: 16;
SIGCHLD :: 17;
SIGCONT :: 18;
SIGSTOP :: 19;
SIGTSTP :: 20;
SIGTTIN :: 21;
SIGTTOU :: 22;
SIGURG :: 23;
SIGXCPU :: 24;
SIGXFSZ :: 25;
SIGVTALRM :: 26;
SIGPROF :: 27;
SIGWINCH :: 28;
SIGIO :: 29;
SIGPOLL :: SIGIO;
SIGPWR :: 30;
SIGSYS :: 31;
SIGUNUSED :: 31;
__SIGRTMIN :: 32;

__SIGRTMAX :: _KERNEL__NSIG;

SI_MAX_SIZE :: 128;

__ARCH_SI_CLOCK_T :: s64;

SI_USER :: 0;
SI_KERNEL :: 0x80;
SI_QUEUE :: - 1;
SI_TIMER :: - 2;
SI_MESGQ :: - 3;
SI_ASYNCIO :: - 4;
SI_SIGIO :: - 5;
SI_TKILL :: - 6;
SI_DETHREAD :: - 7;
SI_ASYNCNL :: - 60;

ILL_ILLOPC :: 1;
ILL_ILLOPN :: 2;
ILL_ILLADR :: 3;
ILL_ILLTRP :: 4;
ILL_PRVOPC :: 5;
ILL_PRVREG :: 6;
ILL_COPROC :: 7;
ILL_BADSTK :: 8;
ILL_BADIADDR :: 9;
__ILL_BREAK :: 10;
__ILL_BNDMOD :: 11;
NSIGILL :: 11;
FPE_INTDIV :: 1;
FPE_INTOVF :: 2;
FPE_FLTDIV :: 3;
FPE_FLTOVF :: 4;
FPE_FLTUND :: 5;
FPE_FLTRES :: 6;
FPE_FLTINV :: 7;
FPE_FLTSUB :: 8;
__FPE_DECOVF :: 9;
__FPE_DECDIV :: 10;
__FPE_DECERR :: 11;
__FPE_INVASC :: 12;
__FPE_INVDEC :: 13;
FPE_FLTUNK :: 14;
FPE_CONDTRAP :: 15;
NSIGFPE :: 15;
SEGV_MAPERR :: 1;
SEGV_ACCERR :: 2;
SEGV_BNDERR :: 3;

SEGV_PKUERR :: 4;

SEGV_ACCADI :: 5;
SEGV_ADIDERR :: 6;
SEGV_ADIPERR :: 7;
SEGV_MTEAERR :: 8;
SEGV_MTESERR :: 9;
NSIGSEGV :: 9;
BUS_ADRALN :: 1;
BUS_ADRERR :: 2;
BUS_OBJERR :: 3;
BUS_MCEERR_AR :: 4;
BUS_MCEERR_AO :: 5;
NSIGBUS :: 5;
TRAP_BRKPT :: 1;
TRAP_TRACE :: 2;
TRAP_BRANCH :: 3;
TRAP_HWBKPT :: 4;
TRAP_UNK :: 5;
TRAP_PERF :: 6;
NSIGTRAP :: 6;
TRAP_PERF_FLAG_ASYNC :: 1 << 0;
CLD_EXITED :: 1;
CLD_KILLED :: 2;
CLD_DUMPED :: 3;
CLD_TRAPPED :: 4;
CLD_STOPPED :: 5;
CLD_CONTINUED :: 6;
NSIGCHLD :: 6;
POLL_IN :: 1;
POLL_OUT :: 2;
POLL_MSG :: 3;
POLL_ERR :: 4;
POLL_PRI :: 5;
POLL_HUP :: 6;
NSIGPOLL :: 6;
SYS_SECCOMP :: 1;
SYS_USER_DISPATCH :: 2;
NSIGSYS :: 2;
EMT_TAGOVF :: 1;
NSIGEMT :: 1;
SIGEV_SIGNAL :: 0;
SIGEV_NONE :: 1;
SIGEV_THREAD :: 2;
SIGEV_THREAD_ID :: 4;

SIGEV_MAX_SIZE :: 64;

SS_ONSTACK :: 1;
SS_DISABLE :: 2;
SS_AUTODISARM :: 1 << 31;
SS_FLAG_BITS :: SS_AUTODISARM;

_NSIG :: _KERNEL__NSIG + 1;
NSIG :: _NSIG;

PAGE_SIZE :: 4096;
PAGE_MASK :: ~(PAGE_SIZE - 1);

NGREG :: 34;

IPC_PRIVATE :: cast(s32) 0;

IPC_CREAT :: 0x200 /* 00001000 */;
IPC_EXCL :: 0x400 /* 00002000 */;
IPC_NOWAIT :: 0x800 /* 00004000 */;
IPC_DIPC :: 0x1000 /* 00010000 */;
IPC_OWN :: 0x2000 /* 00020000 */;
IPC_RMID :: 0;
IPC_SET :: 1;
IPC_STAT :: 2;
IPC_INFO :: 3;
IPC_OLD :: 0;
IPC_64 :: 0x0100;

SEMOP :: 1;
SEMGET :: 2;
SEMCTL :: 3;
SEMTIMEDOP :: 4;
MSGSND :: 11;
MSGRCV :: 12;
MSGGET :: 13;
MSGCTL :: 14;
SHMAT :: 21;
SHMDT :: 22;
SHMGET :: 23;
SHMCTL :: 24;
DIPC :: 25;

PROT_READ :: 0x1;
PROT_WRITE :: 0x2;
PROT_EXEC :: 0x4;
PROT_SEM :: 0x8;
PROT_NONE :: 0x0;
PROT_GROWSDOWN :: 0x01000000;
PROT_GROWSUP :: 0x02000000;
MAP_TYPE :: 0x0f;
MAP_FIXED :: 0x10;
MAP_ANONYMOUS :: 0x20;
MAP_POPULATE :: 0x008000;
MAP_NONBLOCK :: 0x010000;
MAP_STACK :: 0x020000;
MAP_HUGETLB :: 0x040000;
MAP_SYNC :: 0x080000;
MAP_FIXED_NOREPLACE :: 0x100000;
MAP_UNINITIALIZED :: 0x4000000;
MLOCK_ONFAULT :: 0x01;
MS_ASYNC :: 1;
MS_INVALIDATE :: 2;
MS_SYNC :: 4;
MADV_NORMAL :: 0;
MADV_RANDOM :: 1;
MADV_SEQUENTIAL :: 2;
MADV_WILLNEED :: 3;
MADV_DONTNEED :: 4;
MADV_FREE :: 8;
MADV_REMOVE :: 9;
MADV_DONTFORK :: 10;
MADV_DOFORK :: 11;
MADV_HWPOISON :: 100;
MADV_SOFT_OFFLINE :: 101;
MADV_MERGEABLE :: 12;
MADV_UNMERGEABLE :: 13;
MADV_HUGEPAGE :: 14;
MADV_NOHUGEPAGE :: 15;
MADV_DONTDUMP :: 16;
MADV_DODUMP :: 17;
MADV_WIPEONFORK :: 18;
MADV_KEEPONFORK :: 19;
MADV_COLD :: 20;
MADV_PAGEOUT :: 21;
MADV_POPULATE_READ :: 22;
MADV_POPULATE_WRITE :: 23;
MADV_DONTNEED_LOCKED :: 24;
MADV_COLLAPSE :: 25;
MAP_FILE :: 0;
PKEY_DISABLE_ACCESS :: 0x1;
PKEY_DISABLE_WRITE :: 0x2;
PKEY_ACCESS_MASK :: PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE;

MAP_GROWSDOWN :: 0x0100;
MAP_DENYWRITE :: 0x0800;
MAP_EXECUTABLE :: 0x1000;
MAP_LOCKED :: 0x2000;
MAP_NORESERVE :: 0x4000;
MCL_CURRENT :: 1;
MCL_FUTURE :: 2;
MCL_ONFAULT :: 4;

PROT_BTI :: 0x10;
PROT_MTE :: 0x20;

MREMAP_MAYMOVE :: 1;
MREMAP_FIXED :: 2;
MREMAP_DONTUNMAP :: 4;
OVERCOMMIT_GUESS :: 0;
OVERCOMMIT_ALWAYS :: 1;
OVERCOMMIT_NEVER :: 2;
MAP_SHARED :: 0x01;
MAP_PRIVATE :: 0x02;
MAP_SHARED_VALIDATE :: 0x03;

MAP_ANON :: MAP_ANONYMOUS;

POLLIN :: 0x0001;
POLLPRI :: 0x0002;
POLLOUT :: 0x0004;
POLLERR :: 0x0008;
POLLHUP :: 0x0010;
POLLNVAL :: 0x0020;
POLLRDNORM :: 0x0040;
POLLRDBAND :: 0x0080;

POLLWRNORM :: 0x0100;

POLLWRBAND :: 0x0200;

POLLMSG :: 0x0400;

POLLREMOVE :: 0x1000;

POLLRDHUP :: 0x2000;

POLLFREE :: cast(u32) 0x4000;
POLL_BUSY_LOOP :: cast(u32) 0x8000;

ITIMER_REAL :: 0;
ITIMER_VIRTUAL :: 1;
ITIMER_PROF :: 2;
clockid_t :: enum u32 {
    REALTIME           :: 0;
    MONOTONIC          :: 1;
    PROCESS_CPUTIME_ID :: 2;
    THREAD_CPUTIME_ID  :: 3;
    MONOTONIC_RAW      :: 4;
    REALTIME_COARSE    :: 5;
    MONOTONIC_COARSE   :: 6;
    BOOTTIME           :: 7;
    REALTIME_ALARM     :: 8;
    BOOTTIME_ALARM     :: 9;
    SGI_CYCLE          :: 10;
    TAI                :: 11;

    CLOCK_REALTIME           :: REALTIME;
    CLOCK_MONOTONIC          :: MONOTONIC;
    CLOCK_PROCESS_CPUTIME_ID :: PROCESS_CPUTIME_ID;
    CLOCK_THREAD_CPUTIME_ID  :: THREAD_CPUTIME_ID;
    CLOCK_MONOTONIC_RAW      :: MONOTONIC_RAW;
    CLOCK_REALTIME_COARSE    :: REALTIME_COARSE;
    CLOCK_MONOTONIC_COARSE   :: MONOTONIC_COARSE;
    CLOCK_BOOTTIME           :: BOOTTIME;
    CLOCK_REALTIME_ALARM     :: REALTIME_ALARM;
    CLOCK_BOOTTIME_ALARM     :: BOOTTIME_ALARM;
    CLOCK_SGI_CYCLE          :: SGI_CYCLE;
    CLOCK_TAI                :: TAI;
}

MAX_CLOCKS :: 16;
CLOCKS_MASK :: xx clockid_t.REALTIME | xx clockid_t.MONOTONIC;
CLOCKS_MONO :: xx clockid_t.MONOTONIC;
TIMER_ABSTIME :: 0x01;

CLOCKS_PER_SEC :: 1000000;

TIME_UTC :: xx clockid_t.REALTIME+1;

TIME_MONOTONIC :: xx clockid_t.MONOTONIC+1;

TIME_ACTIVE :: xx clockid_t.PROCESS_CPUTIME_ID+1;

TIME_THREAD_ACTIVE :: xx clockid_t.THREAD_CPUTIME_ID+1;

SEEK_SET :: 0;

SEEK_CUR :: 1;

SEEK_END :: 2;

SEEK_DATA :: 3;

SEEK_HOLE :: 4;

STDIN_FILENO :: 0;
STDOUT_FILENO :: 1;
STDERR_FILENO :: 2;

F_OK :: 0;
X_OK :: 1;
W_OK :: 2;
R_OK :: 4;

PC :: enum u32 {
    FILESIZEBITS       :: 0;
    LINK_MAX           :: 1;
    MAX_CANON          :: 2;
    MAX_INPUT          :: 3;
    NAME_MAX           :: 4;
    PATH_MAX           :: 5;
    PIPE_BUF           :: 6;
    _2_SYMLINKS        :: 7;
    ALLOC_SIZE_MIN     :: 8;
    REC_INCR_XFER_SIZE :: 9;
    REC_MAX_XFER_SIZE  :: 10;
    REC_MIN_XFER_SIZE  :: 11;
    REC_XFER_ALIGN     :: 12;
    SYMLINK_MAX        :: 13;
    CHOWN_RESTRICTED   :: 14;
    NO_TRUNC           :: 15;
    VDISABLE           :: 16;
    ASYNC_IO           :: 17;
    PRIO_IO            :: 18;
    SYNC_IO            :: 19;
}

SHMMIN :: 1;
SHMMNI :: 4096;

SHMSEG :: SHMMNI;

SHM_R :: 0x100 /* 0400 */;
SHM_W :: 0x80 /* 0200 */;
SHM_HUGETLB :: 0x800 /* 04000 */;
SHM_NORESERVE :: 0x1000 /* 010000 */;

SHM_RDONLY :: 0x1000 /* 010000 */;
SHM_RND :: 0x2000 /* 020000 */;
SHM_REMAP :: 0x4000 /* 040000 */;
SHM_EXEC :: 0x8000 /* 0100000 */;
SHM_LOCK :: 11;
SHM_UNLOCK :: 12;
SHM_STAT :: 13;
SHM_INFO :: 14;
SHM_STAT_ANY :: 15;

SHMLBA :: 4096;

SYS_NMLN :: 65;

WNOHANG :: 0x00000001;
WUNTRACED :: 0x00000002;
WSTOPPED :: WUNTRACED;
WEXITED :: 0x00000004;
WCONTINUED :: 0x00000008;
WNOWAIT :: 0x01000000;
__WNOTHREAD :: 0x20000000;
__WALL :: 0x40000000;
__WCLONE :: 0x80000000;
P_ALL :: 0;
P_PID :: 1;
P_PGID :: 2;
P_PIDFD :: 3;

ptrdiff_t :: s64;

Dl_info :: struct {
    /* Pathname of shared object that contains address. */
    dli_fname: *u8;

    /* Address at which shared object is loaded. */
    dli_fbase: *void;

    /* Name of nearest symbol with address lower than addr. */
    dli_sname: *u8;

    /* Exact address of symbol named in dli_sname. */
    dli_saddr: *void;
}

dlopen :: (__filename: *u8, __flag: s32) -> *void #foreign libdl;
dlclose :: (__handle: *void) -> s32 #foreign libdl;
dlerror :: () -> *u8 #foreign libdl;

/* (RTLD_DEFAULT is null for LP64, but -1 for LP32) */
dlsym :: (__handle: *void, __symbol: *u8) -> *void #foreign libdl;

dlvsym :: (__handle: *void, __symbol: *u8, __version: *u8) -> *void #foreign libdl;

dladdr :: (__addr: *void, __info: *Dl_info) -> s32 #foreign libdl;

__kernel_fd_set :: struct {
    fds_bits: [16] u64;
}

__kernel_fsid_t :: struct {
    val: [2] s32;
}

gid_t :: u32;

uid_t :: u32;

pid_t :: s32;

blkcnt_t :: u64;
blksize_t :: u64;

clock_t :: s64;

fsblkcnt_t :: u64;
fsfilcnt_t :: u64;

mode_t :: u32;

key_t :: s32;

ino_t :: u64;

ino64_t :: u64;

nlink_t :: u32;

timer_t :: *void;

suseconds_t :: s64;

useconds_t :: u32;

dev_t :: u64;

time_t :: s64;

uint_t :: u32;

/** The structure returned by readdir(). Identical to dirent64 on Android. */
dirent :: struct {
    d_ino:    ino_t;
    d_off:    s64;
    d_reclen: u16;
    d_type:   DT;
    d_name:   [256] u8;
}

/** The structure returned by readdir64(). Identical to dirent on Android. */
dirent64 :: struct {
    d_ino:    ino_t;
    d_off:    s64;
    d_reclen: u16;
    d_type:   DT;
    d_name:   [256] u8;
}

DIR :: struct {}

/**
* [opendir(3)](http://man7.org/linux/man-pages/man3/opendir.3.html)
* opens a directory stream for the directory at `__path`.
*
* Returns null and sets `errno` on failure.
*/
opendir :: (__path: *u8) -> *DIR #foreign libc;

/**
* [fopendir(3)](http://man7.org/linux/man-pages/man3/opendir.3.html)
* opens a directory stream for the directory at `__dir_fd`.
*
* Returns null and sets `errno` on failure.
*/
fdopendir :: (__dir_fd: s32) -> *DIR #foreign libc;

/**
* [readdir(3)](http://man7.org/linux/man-pages/man3/readdir.3.html)
* returns the next directory entry in the given directory.
*
* Returns a pointer to a directory entry on success,
* or returns null and leaves `errno` unchanged at the end of the directory,
* or returns null and sets `errno` on failure.
*/
readdir :: (__dir: *DIR) -> *dirent #foreign libc;

readdir64 :: (__dir: *DIR) -> *dirent64 #foreign libc;

readdir_r :: (__dir: *DIR, __entry: *dirent, __buffer: **dirent) -> s32 #foreign libc;

readdir64_r :: (__dir: *DIR, __entry: *dirent64, __buffer: **dirent64) -> s32 #foreign libc;

/**
* [closedir(3)](http://man7.org/linux/man-pages/man3/closedir.3.html)
* closes a directory stream.
*
* Returns 0 on success and returns -1 and sets `errno` on failure.
*/
closedir :: (__dir: *DIR) -> s32 #foreign libc;

/**
* [rewinddir(3)](http://man7.org/linux/man-pages/man3/rewinddir.3.html)
* rewinds a directory stream to the first entry.
*/
rewinddir :: (__dir: *DIR) -> void #foreign libc;

seekdir :: (__dir: *DIR, __location: s64) -> void #foreign libc;

/**
* [telldir(3)](http://man7.org/linux/man-pages/man3/telldir.3.html)
* returns a value representing the current position in the directory
* for use with seekdir().
*
* Returns the current position on success and returns -1 and sets `errno` on failure.
*
* Available since API level 23.
*/
telldir :: (__dir: *DIR) -> s64 #foreign libc;

/**
* [dirfd(3)](http://man7.org/linux/man-pages/man3/dirfd.3.html)
* returns the file descriptor backing the given directory stream.
*
* Returns a file descriptor on success and returns -1 and sets `errno` on failure.
*/
dirfd :: (__dir: *DIR) -> s32 #foreign libc;

/**
* [alphasort](http://man7.org/linux/man-pages/man3/alphasort.3.html) is a
* comparator for use with scandir() that uses strcoll().
*/
alphasort :: (__lhs: **dirent, __rhs: **dirent) -> s32 #foreign libc;

alphasort64 :: (__lhs: **dirent64, __rhs: **dirent64) -> s32 #foreign libc;

/**
* [scandir(3)](http://man7.org/linux/man-pages/man3/scandir.3.html)
* scans all the directory `__path`, filtering entries with `__filter` and
* sorting them with qsort() using the given `__comparator`, and storing them
* into `__name_list`. Passing NULL as the filter accepts all entries.
* Passing NULL as the comparator skips sorting.
*
* Returns the number of entries returned in the list on success,
* and returns -1 and sets `errno` on failure.
*/
scandir :: (__path: *u8, __name_list: ***dirent, __filter: #type (unknown0: *dirent) -> s32 #c_call, __comparator: #type (unknown0: **dirent, unknown1: **dirent) -> s32 #c_call) -> s32 #foreign libc;

scandir64 :: (__path: *u8, __name_list: ***dirent64, __filter: #type (unknown0: *dirent64) -> s32 #c_call, __comparator: #type (unknown0: **dirent64, unknown1: **dirent64) -> s32 #c_call) -> s32 #foreign libc;

scandirat64 :: (__dir_fd: s32, __path: *u8, __name_list: ***dirent64, __filter: #type (unknown0: *dirent64) -> s32 #c_call, __comparator: #type (unknown0: **dirent64, unknown1: **dirent64) -> s32 #c_call) -> s32 #foreign libc;

/**
* [scandirat(3)](http://man7.org/linux/man-pages/man3/scandirat.3.html)
* scans all the directory referenced by the pair of `__dir_fd` and `__path`,
* filtering entries with `__filter` and sorting them with qsort() using the
* given `__comparator`, and storing them into `__name_list`. Passing NULL as
* the filter accepts all entries.
* Passing NULL as the comparator skips sorting.
*
* Returns the number of entries returned in the list on success,
* and returns -1 and sets `errno` on failure.
*
* Available since API level 24.
*/
scandirat :: (__dir_fd: s32, __path: *u8, __name_list: ***dirent, __filter: #type (unknown0: *dirent) -> s32 #c_call, __comparator: #type (unknown0: **dirent, unknown1: **dirent) -> s32 #c_call) -> s32 #foreign libc;

/**
* Returns the address of the calling thread's `errno` storage.
* Non-portable and should not be used directly. Use `errno` instead.
*
* @private
*/
__errno_location :: () -> *OS_Error_Code #foreign libc "__errno";

backtrace :: (buffer: **void, size: s32) -> s32 #foreign libc;

/**
* [backtrace_symbols(3)](https://man7.org/linux/man-pages/man3/backtrace_symbols.3.html)
* Given an array of void* pointers, translate the addresses into an array
* of strings that represent the backtrace.
*
* Returns a pointer to allocated memory, on error NULL is returned. It is
* the responsibility of the caller to free the returned memory.
*
* Available since API level 33.
*/
backtrace_symbols :: (buffer: **void, size: s32) -> **u8 #foreign libc;

/**
* [backtrace_symbols_fd(3)](https://man7.org/linux/man-pages/man3/backtrace_symbols_fd.3.html)
* Given an array of void* pointers, translate the addresses into an array
* of strings that represent the backtrace and write to the file represented
* by "fd". The file is written such that one line equals one void* address.
*
* Available since API level 33.
*/
backtrace_symbols_fd :: (buffer: **void, size: s32, fd: s32) -> void #foreign libc;

/**
* [fnmatch(3)](http://man7.org/linux/man-pages/man3/fnmatch.3.html) matches `__string` against
* the shell wildcard `__pattern`.
*
* Returns 0 on success, and returns `FNM_NOMATCH` on failure.
*/
fnmatch :: (__pattern: *u8, __string: *u8, __flags: s32) -> s32 #foreign libc;

passwd :: struct {
    pw_name:   *u8;
    pw_passwd: *u8;
    pw_uid:    uid_t;
    pw_gid:    gid_t;

    pw_gecos:  *u8;

    pw_dir:    *u8;
    pw_shell:  *u8;
}

getpwnam :: (__name: *u8) -> *passwd #foreign libc;
getpwuid :: (__uid: uid_t) -> *passwd #foreign libc;

getpwent :: () -> *passwd #foreign libc;

setpwent :: () -> void #foreign libc;
endpwent :: () -> void #foreign libc;

getpwnam_r :: (__name: *u8, __pwd: *passwd, __buf: *u8, __n: u64, __result: **passwd) -> s32 #foreign libc;
getpwuid_r :: (__uid: uid_t, __pwd: *passwd, __buf: *u8, __n: u64, __result: **passwd) -> s32 #foreign libc;

sigcontext :: struct {
    fault_address: u64;
    regs:          [31] u64;
    sp:            u64;
    pc:            u64;
    pstate:        u64;
    __reserved:    [4096] u8 #align 9;
}

sigset_t :: struct {
    sig: [1] u64;
}

old_sigset_t :: u64;

__kernel_sigaction :: struct {
    sa_handler:  #type (unknown0: s32) -> void #c_call;
    sa_flags:    u64;

    sa_restorer: #type () -> void #c_call;

    sa_mask:     sigset_t;
}

sigaltstack_t :: struct {
    ss_sp:    *void;
    ss_flags: s32;
    ss_size:  u64;
}

stack_t :: sigaltstack_t;

sigval :: union {
    sival_int: s32;
    sival_ptr: *void;
}

sigval_t :: sigval;

__sifields :: union {
    _kill:     struct {
        _pid: s32;
        _uid: u32;
    };

    _timer:    struct {
        _tid:         s32;
        _overrun:     s32;
        _sigval:      sigval_t;
        _sys_private: s32;
    };

    _rt:       struct {
        _pid:    s32;
        _uid:    u32;
        _sigval: sigval_t;
    };

    _sigchld:  struct {
        _pid:    s32;
        _uid:    u32;
        _status: s32;
        _utime:  s64;
        _stime:  s64;
    };

    _sigfault: struct {
        _addr: *void;

        union {
            _trapno:    s32;
            _addr_lsb:  s16;
            _addr_bnd:  struct {
                _dummy_bnd: [8] u8;
                _lower:     *void;
                _upper:     *void;
            };

            _addr_pkey: struct {
                _dummy_pkey: [8] u8;
                _pkey:       u32;
            };

            _perf:      struct {
                _data:  u64;
                _type:  u32;
                _flags: u32;
            };
        }
    };

    _sigpoll:  struct {
        _band: s64;
        _fd:   s32;
    };

    _sigsys:   struct {
        _call_addr: *void;
        _syscall:   s32;
        _arch:      u32;
    };
}

siginfo :: struct {
    union {
        struct {
            si_signo:  s32;
            si_errno:  s32;
            si_code:   s32;
            _sifields: __sifields;
        }
        _si_pad: [32] s32;
    }
}

siginfo_t :: siginfo;

sigevent :: struct {
    sigev_value:  sigval_t;
    sigev_signo:  s32;
    sigev_notify: s32;
    _sigev_un:    union {
        _pad:          [12] s32;
        _tid:          s32;
        _sigev_thread: struct {
            _function:  #type (unknown0: sigval_t) -> void #c_call;
            _attribute: *void;
        };
    };
}

sigevent_t :: sigevent;

sig_atomic_t :: s32;

sig_t :: #type (unknown0: s32) -> void #c_call;
sighandler_t :: #type (unknown0: s32) -> void #c_call;

sigset64_t :: sigset_t;

sigaction_t :: struct {
    sa_flags:    s32;
    union {
        sa_handler:   sighandler_t;
        sa_sigaction: #type (unknown0: s32, unknown1: *siginfo, unknown2: *void) -> void #c_call;
    }
    sa_mask:     sigset_t;
    sa_restorer: #type () -> void #c_call;
}
sigaction64_t :: struct {
    sa_flags:    s32;
    union {
        sa_handler:   sighandler_t;
        sa_sigaction: #type (unknown0: s32, unknown1: *siginfo, unknown2: *void) -> void #c_call;
    }
    sa_mask:     sigset_t;
    sa_restorer: #type () -> void #c_call;
}

timespec :: struct {
    tv_sec:  time_t;

    tv_nsec: s64;
}

user_regs_struct :: struct {
    regs:   [31] u64;
    sp:     u64;
    pc:     u64;
    pstate: u64;
}

user_fpsimd_struct :: struct {
    vregs: [32] U128;
    fpsr:  u32;
    fpcr:  u32;
}

greg_t :: u64;
gregset_t :: [34] greg_t;
fpregset_t :: user_fpsimd_struct;

mcontext_t :: sigcontext;

ucontext :: struct {
    uc_flags:    u64;
    uc_link:     *ucontext;
    uc_stack:    stack_t;
    union {
        uc_sigmask:   sigset_t;
        uc_sigmask64: sigset64_t;
    }

    __padding:   [120] u8;
    uc_mcontext: mcontext_t #align 16;
}

ucontext_t :: ucontext;

__libc_current_sigrtmin :: () -> s32 #foreign libc;
__libc_current_sigrtmax :: () -> s32 #foreign libc;

sys_siglist: [65] *u8 #elsewhere libc;
sys_signame: [65] *u8 #elsewhere libc; /* BSD compatibility. */

sigaction :: (__signal: s32, __new_action: *sigaction_t, __old_action: *sigaction_t) -> s32 #foreign libc;

sigaction64 :: (__signal: s32, __new_action: *sigaction64_t, __old_action: *sigaction64_t) -> s32 #foreign libc;

siginterrupt :: (__signal: s32, __flag: s32) -> s32 #foreign libc;

signal :: (__signal: s32, __handler: sighandler_t) -> sighandler_t #foreign libc;
sigaddset :: (__set: *sigset_t, __signal: s32) -> s32 #foreign libc;

sigaddset64 :: (__set: *sigset64_t, __signal: s32) -> s32 #foreign libc;

sigdelset :: (__set: *sigset_t, __signal: s32) -> s32 #foreign libc;

sigdelset64 :: (__set: *sigset64_t, __signal: s32) -> s32 #foreign libc;

sigemptyset :: (__set: *sigset_t) -> s32 #foreign libc;

sigemptyset64 :: (__set: *sigset64_t) -> s32 #foreign libc;

sigfillset :: (__set: *sigset_t) -> s32 #foreign libc;

sigfillset64 :: (__set: *sigset64_t) -> s32 #foreign libc;

sigismember :: (__set: *sigset_t, __signal: s32) -> s32 #foreign libc;

sigismember64 :: (__set: *sigset64_t, __signal: s32) -> s32 #foreign libc;

sigpending :: (__set: *sigset_t) -> s32 #foreign libc;

sigpending64 :: (__set: *sigset64_t) -> s32 #foreign libc;

sigprocmask :: (__how: s32, __new_set: *sigset_t, __old_set: *sigset_t) -> s32 #foreign libc;

sigprocmask64 :: (__how: s32, __new_set: *sigset64_t, __old_set: *sigset64_t) -> s32 #foreign libc;

sigsuspend :: (__mask: *sigset_t) -> s32 #foreign libc;

sigsuspend64 :: (__mask: *sigset64_t) -> s32 #foreign libc;

sigwait :: (__set: *sigset_t, __signal: *s32) -> s32 #foreign libc;

sigwait64 :: (__set: *sigset64_t, __signal: *s32) -> s32 #foreign libc;

sighold :: (__signal: s32) -> s32 #foreign libc;

sigignore :: (__signal: s32) -> s32 #foreign libc;

sigpause :: (__signal: s32) -> s32 #foreign libc;

sigrelse :: (__signal: s32) -> s32 #foreign libc;

sigset :: (__signal: s32, __handler: sighandler_t) -> sighandler_t #foreign libc;

raise :: (__signal: s32) -> s32 #foreign libc;
kill :: (__pid: pid_t, __signal: s32) -> s32 #foreign libc;
killpg :: (__pgrp: s32, __signal: s32) -> s32 #foreign libc;
tgkill :: (__tgid: s32, __tid: s32, __signal: s32) -> s32 #foreign libc;

sigaltstack :: (__new_signal_stack: *stack_t, __old_signal_stack: *stack_t) -> s32 #foreign libc;

psiginfo :: (__info: *siginfo_t, __msg: *u8) -> void #foreign libc;
psignal :: (__signal: s32, __msg: *u8) -> void #foreign libc;

sigqueue :: (__pid: pid_t, __signal: s32, __value: sigval) -> s32 #foreign libc;
sigtimedwait :: (__set: *sigset_t, __info: *siginfo_t, __timeout: *timespec) -> s32 #foreign libc;

sigtimedwait64 :: (__set: *sigset64_t, __info: *siginfo_t, __timeout: *timespec) -> s32 #foreign libc;

sigwaitinfo :: (__set: *sigset_t, __info: *siginfo_t) -> s32 #foreign libc;

sigwaitinfo64 :: (__set: *sigset64_t, __info: *siginfo_t) -> s32 #foreign libc;

ipc_kludge :: struct {
    msgbuf :: struct {}
    msgp:   *msgbuf;
    msgtyp: s64;
}

/**
* [ftok(3)](http://man7.org/linux/man-pages/man3/ftok.3.html) converts a path and id to a
* System V IPC key.
*
* Returns a key on success, and returns -1 and sets `errno` on failure.
*/
ftok :: (__path: *u8, __id: s32) -> key_t #foreign libc;

iovec :: struct {
    iov_base: *void;
    iov_len:  u64;
}

mmap :: (__addr: *void, __size: u64, __prot: s32, __flags: s32, __fd: s32, __offset: s64) -> *void #foreign libc;

mmap64 :: (__addr: *void, __size: u64, __prot: s32, __flags: s32, __fd: s32, __offset: s64) -> *void #foreign libc;

/**
* [munmap(2)](http://man7.org/linux/man-pages/man2/munmap.2.html)
* deletes a memory mapping for the given range.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
munmap :: (__addr: *void, __size: u64) -> s32 #foreign libc;

/**
* [msync(2)](http://man7.org/linux/man-pages/man2/msync.2.html)
* flushes changes to a memory-mapped file to disk.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
msync :: (__addr: *void, __size: u64, __flags: s32) -> s32 #foreign libc;

/**
* [mprotect(2)](http://man7.org/linux/man-pages/man2/mprotect.2.html)
* sets the protection on a memory region.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
mprotect :: (__addr: *void, __size: u64, __prot: s32) -> s32 #foreign libc;

/**
* [mremap(2)](http://man7.org/linux/man-pages/man2/mremap.2.html)
* expands or shrinks an existing memory mapping.
*
* Returns the address of the mapping on success,
* and returns `MAP_FAILED` and sets `errno` on failure.
*/
mremap :: (__old_addr: *void, __old_size: u64, __new_size: u64, __flags: s32, __args: ..Any) -> *void #foreign libc;

mlockall :: (__flags: s32) -> s32 #foreign libc;

/**
* [munlockall(2)](http://man7.org/linux/man-pages/man2/munlockall.2.html)
* unlocks pages (allowing swapping).
*
* Available since API level 17.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
munlockall :: () -> s32 #foreign libc;

/**
* [mlock(2)](http://man7.org/linux/man-pages/man2/mlock.2.html)
* locks pages (preventing swapping).
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
mlock :: (__addr: *void, __size: u64) -> s32 #foreign libc;

mlock2 :: (__addr: *void, __size: u64, __flags: s32) -> s32 #foreign libc;

/**
* [munlock(2)](http://man7.org/linux/man-pages/man2/munlock.2.html)
* unlocks pages (allowing swapping).
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
munlock :: (__addr: *void, __size: u64) -> s32 #foreign libc;

/**
* [mincore(2)](http://man7.org/linux/man-pages/man2/mincore.2.html)
* tests whether pages are resident in memory.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
mincore :: (__addr: *void, __size: u64, __vector: *u8) -> s32 #foreign libc;

/**
* [madvise(2)](http://man7.org/linux/man-pages/man2/madvise.2.html)
* gives the kernel advice about future usage patterns.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
madvise :: (__addr: *void, __size: u64, __advice: s32) -> s32 #foreign libc;

process_madvise :: (__pid_fd: s32, __iov: *iovec, __count: u64, __advice: s32, __flags: u32) -> s64 #foreign libc;

memfd_create :: (__name: *u8, __flags: u32) -> s32 #foreign libc;

posix_madvise :: (__addr: *void, __size: u64, __advice: s32) -> s32 #foreign libc;

pollfd :: struct {
    fd:      s32;
    events:  s16;
    revents: s16;
}

timeval :: struct {
    tv_sec:  s64;
    tv_usec: s64;
}

itimerspec :: struct {
    it_interval: timespec;
    it_value:    timespec;
}

itimerval :: struct {
    it_interval: timeval;
    it_value:    timeval;
}

timezone :: struct {
    tz_minuteswest: s32;
    tz_dsttime:     s32;
}

gettimeofday :: (__tv: *timeval, __tz: *timezone) -> s32 #foreign libc;
settimeofday :: (__tv: *timeval, __tz: *timezone) -> s32 #foreign libc;

getitimer :: (__which: s32, __current_value: *itimerval) -> s32 #foreign libc;
setitimer :: (__which: s32, __new_value: *itimerval, __old_value: *itimerval) -> s32 #foreign libc;

utimes :: (__path: *u8, __times: *[2] timeval) -> s32 #foreign libc;

futimes :: (__fd: s32, __times: *[2] timeval) -> s32 #foreign libc;
lutimes :: (__path: *u8, __times: *[2] timeval) -> s32 #foreign libc;

futimesat :: (__dir_fd: s32, __path: *u8, __times: *[2] timeval) -> s32 #foreign libc;

__locale_t :: struct {}

locale_t :: *__locale_t;

tzname: **u8 #elsewhere libc;

daylight: s32 #elsewhere libc;

tm :: struct {
    tm_sec:    s32;

    tm_min:    s32;

    tm_hour:   s32;

    tm_mday:   s32;

    tm_mon:    s32;

    tm_year:   s32;

    tm_wday:   s32;

    tm_yday:   s32;

    tm_isdst:  s32;

    tm_gmtoff: s64;

    tm_zone:   *u8;
}

time :: (__t: *time_t) -> time_t #foreign libc;

nanosleep :: (__request: *timespec, __remainder: *timespec) -> s32 #foreign libc;

asctime :: (__tm: *tm) -> *u8 #foreign libc;

asctime_r :: (__tm: *tm, __buf: *u8) -> *u8 #foreign libc;

difftime :: (__lhs: time_t, __rhs: time_t) -> float64 #foreign libc;

mktime :: (__tm: *tm) -> time_t #foreign libc;

localtime :: (__t: *time_t) -> *tm #foreign libc;

localtime_r :: (__t: *time_t, __tm: *tm) -> *tm #foreign libc;

timelocal :: (__tm: *tm) -> time_t #foreign libc;

gmtime :: (__t: *time_t) -> *tm #foreign libc;

gmtime_r :: (__t: *time_t, __tm: *tm) -> *tm #foreign libc;

timegm :: (__tm: *tm) -> time_t #foreign libc;

strptime :: (__s: *u8, __fmt: *u8, __tm: *tm) -> *u8 #foreign libc;

strptime_l :: (__s: *u8, __fmt: *u8, __tm: *tm, __l: locale_t) -> *u8 #foreign libc;

strftime :: (__buf: *u8, __n: u64, __fmt: *u8, __tm: *tm) -> u64 #foreign libc;

strftime_l :: (__buf: *u8, __n: u64, __fmt: *u8, __tm: *tm, __l: locale_t) -> u64 #foreign libc;

ctime :: (__t: *time_t) -> *u8 #foreign libc;

ctime_r :: (__t: *time_t, __buf: *u8) -> *u8 #foreign libc;

tzset :: () -> void #foreign libc;

clock :: () -> clock_t #foreign libc;

clock_getcpuclockid :: (__pid: pid_t, __clock: *clockid_t) -> s32 #foreign libc;

clock_getres :: (__clock: clockid_t, __resolution: *timespec) -> s32 #foreign libc;

clock_gettime :: (__clock: clockid_t, __ts: *timespec) -> s32 #foreign libc;

clock_nanosleep :: (__clock: clockid_t, __flags: s32, __request: *timespec, __remainder: *timespec) -> s32 #foreign libc;

clock_settime :: (__clock: clockid_t, __ts: *timespec) -> s32 #foreign libc;

timer_create :: (__clock: clockid_t, __event: *sigevent, __timer_ptr: *timer_t) -> s32 #foreign libc;

timer_delete :: (__timer: timer_t) -> s32 #foreign libc;

timer_settime :: (__timer: timer_t, __flags: s32, __new_value: *itimerspec, __old_value: *itimerspec) -> s32 #foreign libc;

timer_gettime :: (_timer: timer_t, __ts: *itimerspec) -> s32 #foreign libc;

timer_getoverrun :: (__timer: timer_t) -> s32 #foreign libc;

timespec_get :: (__ts: *timespec, __base: s32) -> s32 #foreign libc;

nfds_t :: u32;

poll :: (__fds: *pollfd, __count: nfds_t, __timeout_ms: s32) -> s32 #foreign libc;

ppoll :: (__fds: *pollfd, __count: nfds_t, __timeout: *timespec, __mask: *sigset_t) -> s32 #foreign libc;

ppoll64 :: (__fds: *pollfd, __count: nfds_t, __timeout: *timespec, __mask: *sigset64_t) -> s32 #foreign libc;

environ: **u8 #elsewhere libc;

_exit :: (__status: s32) -> void #foreign libc;

fork :: () -> pid_t #foreign libc;
vfork :: () -> s32 #foreign libc;
getpid :: () -> pid_t #foreign libc;
gettid :: () -> pid_t #foreign libc;
getpgid :: (__pid: pid_t) -> pid_t #foreign libc;
setpgid :: (__pid: pid_t, __pgid: pid_t) -> s32 #foreign libc;
getppid :: () -> pid_t #foreign libc;
getpgrp :: () -> pid_t #foreign libc;
setpgrp :: () -> s32 #foreign libc;

getsid :: (__pid: pid_t) -> pid_t #foreign libc;

setsid :: () -> pid_t #foreign libc;

execv :: (__path: *u8, __argv: **u8) -> s32 #foreign libc;
execvp :: (__file: *u8, __argv: **u8) -> s32 #foreign libc;

execvpe :: (__file: *u8, __argv: **u8, __envp: **u8) -> s32 #foreign libc;

execve :: (__file: *u8, __argv: **u8, __envp: **u8) -> s32 #foreign libc;
execl :: (__path: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;
execlp :: (__file: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;
execle :: (__path: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;

fexecve :: (__fd: s32, __argv: **u8, __envp: **u8) -> s32 #foreign libc;

nice :: (__incr: s32) -> s32 #foreign libc;

setegid :: (__gid: gid_t) -> s32 #foreign libc;

seteuid :: (__uid: uid_t) -> s32 #foreign libc;

setgid :: (__gid: gid_t) -> s32 #foreign libc;

setregid :: (__rgid: gid_t, __egid: gid_t) -> s32 #foreign libc;

setresgid :: (__rgid: gid_t, __egid: gid_t, __sgid: gid_t) -> s32 #foreign libc;

setresuid :: (__ruid: uid_t, __euid: uid_t, __suid: uid_t) -> s32 #foreign libc;

setreuid :: (__ruid: uid_t, __euid: uid_t) -> s32 #foreign libc;

setuid :: (__uid: uid_t) -> s32 #foreign libc;

getuid :: () -> uid_t #foreign libc;
geteuid :: () -> uid_t #foreign libc;
getgid :: () -> gid_t #foreign libc;
getegid :: () -> gid_t #foreign libc;
getgroups :: (__size: s32, __list: *gid_t) -> s32 #foreign libc;
setgroups :: (__size: u64, __list: *gid_t) -> s32 #foreign libc;
getresuid :: (__ruid: *uid_t, __euid: *uid_t, __suid: *uid_t) -> s32 #foreign libc;
getresgid :: (__rgid: *gid_t, __egid: *gid_t, __sgid: *gid_t) -> s32 #foreign libc;
getlogin :: () -> *u8 #foreign libc;

getlogin_r :: (__buffer: *u8, __buffer_size: u64) -> s32 #foreign libc;

fpathconf :: (__fd: s32, __name: PC) -> s64 #foreign libc;
pathconf :: (__path: *u8, __name: PC) -> s64 #foreign libc;

access :: (__path: *u8, __mode: s32) -> s32 #foreign libc;
faccessat :: (__dirfd: s32, __path: *u8, __mode: s32, __flags: s32) -> s32 #foreign libc;
link :: (__old_path: *u8, __new_path: *u8) -> s32 #foreign libc;

linkat :: (__old_dir_fd: s32, __old_path: *u8, __new_dir_fd: s32, __new_path: *u8, __flags: s32) -> s32 #foreign libc;

unlink :: (__path: *u8) -> s32 #foreign libc;
unlinkat :: (__dirfd: s32, __path: *u8, __flags: s32) -> s32 #foreign libc;
chdir :: (__path: *u8) -> s32 #foreign libc;
fchdir :: (__fd: s32) -> s32 #foreign libc;
rmdir :: (__path: *u8) -> s32 #foreign libc;
pipe :: (__fds: *[2] s32) -> s32 #foreign libc;

pipe2 :: (__fds: *[2] s32, __flags: s32) -> s32 #foreign libc;

chroot :: (__path: *u8) -> s32 #foreign libc;
symlink :: (__old_path: *u8, __new_path: *u8) -> s32 #foreign libc;

symlinkat :: (__old_path: *u8, __new_dir_fd: s32, __new_path: *u8) -> s32 #foreign libc;

readlink :: (__path: *u8, __buf: *u8, __buf_size: u64) -> s64 #foreign libc;

readlinkat :: (__dir_fd: s32, __path: *u8, __buf: *u8, __buf_size: u64) -> s64 #foreign libc;

chown :: (__path: *u8, __owner: uid_t, __group: gid_t) -> s32 #foreign libc;
fchown :: (__fd: s32, __owner: uid_t, __group: gid_t) -> s32 #foreign libc;
fchownat :: (__dir_fd: s32, __path: *u8, __owner: uid_t, __group: gid_t, __flags: s32) -> s32 #foreign libc;
lchown :: (__path: *u8, __owner: uid_t, __group: gid_t) -> s32 #foreign libc;
getcwd :: (__buf: *u8, __size: u64) -> *u8 #foreign libc;

sync :: () -> void #foreign libc;

syncfs :: (__fd: s32) -> s32 #foreign libc;

close :: (__fd: s32) -> s32 #foreign libc;

read :: (__fd: s32, __buf: *void, __count: u64) -> s64 #foreign libc;

write :: (__fd: s32, __buf: *void, __count: u64) -> s64 #foreign libc;

dup :: (__old_fd: s32) -> s32 #foreign libc;
dup2 :: (__old_fd: s32, __new_fd: s32) -> s32 #foreign libc;

dup3 :: (__old_fd: s32, __new_fd: s32, __flags: s32) -> s32 #foreign libc;

fsync :: (__fd: s32) -> s32 #foreign libc;
fdatasync :: (__fd: s32) -> s32 #foreign libc;

truncate :: (__path: *u8, __length: s64) -> s32 #foreign libc;
lseek :: (__fd: s32, __offset: s64, __whence: s32) -> s64 #foreign libc;
pread :: (__fd: s32, __buf: *void, __count: u64, __offset: s64) -> s64 #foreign libc;
pwrite :: (__fd: s32, __buf: *void, __count: u64, __offset: s64) -> s64 #foreign libc;
ftruncate :: (__fd: s32, __length: s64) -> s32 #foreign libc;

truncate64 :: (__path: *u8, __length: s64) -> s32 #foreign libc;

lseek64 :: (__fd: s32, __offset: s64, __whence: s32) -> s64 #foreign libc;
pread64 :: (__fd: s32, __buf: *void, __count: u64, __offset: s64) -> s64 #foreign libc;
pwrite64 :: (__fd: s32, __buf: *void, __count: u64, __offset: s64) -> s64 #foreign libc;
ftruncate64 :: (__fd: s32, __length: s64) -> s32 #foreign libc;

pause :: () -> s32 #foreign libc;
alarm :: (__seconds: u32) -> u32 #foreign libc;
sleep :: (__seconds: u32) -> u32 #foreign libc;
usleep :: (__microseconds: useconds_t) -> s32 #foreign libc;

gethostname :: (_buf: *u8, __buf_size: u64) -> s32 #foreign libc;

sethostname :: (__name: *u8, __n: u64) -> s32 #foreign libc;

brk :: (__addr: *void) -> s32 #foreign libc;
sbrk :: (__increment: ptrdiff_t) -> *void #foreign libc;

isatty :: (__fd: s32) -> s32 #foreign libc;
ttyname :: (__fd: s32) -> *u8 #foreign libc;
ttyname_r :: (__fd: s32, __buf: *u8, __buf_size: u64) -> s32 #foreign libc;

acct :: (__path: *u8) -> s32 #foreign libc;

getpagesize :: () -> s32 #foreign libc;

daemon :: (__no_chdir: s32, __no_close: s32) -> s32 #foreign libc;

tcgetpgrp :: (__fd: s32) -> pid_t #foreign libc;
tcsetpgrp :: (__fd: s32, __pid: pid_t) -> s32 #foreign libc;

getdomainname :: (__buf: *u8, __buf_size: u64) -> s32 #foreign libc;
setdomainname :: (__name: *u8, __n: u64) -> s32 #foreign libc;

copy_file_range :: (__fd_in: s32, __off_in: *s64, __fd_out: s32, __off_out: *s64, __length: u64, __flags: u32) -> s64 #foreign libc;

swab :: (__src: *void, __dst: *void, __byte_count: s64) -> void #foreign libc;

close_range :: (__min_fd: u32, __max_fd: u32, __flags: s32) -> s32 #foreign libc;

shminfo :: struct {
    shmmax: s32;
    shmmin: s32;
    shmmni: s32;
    shmseg: s32;
    shmall: s32;
}

shm_info :: struct {
    used_ids:       s32;
    shm_tot:        u64;
    shm_rss:        u64;
    shm_swp:        u64;
    swap_attempts:  u64;
    swap_successes: u64;
}

shmatt_t :: u64;

shmat :: (__shm_id: s32, __addr: *void, __flags: s32) -> *void #foreign libc;

/** Not useful on Android; disallowed by SELinux. */
shmdt :: (__addr: *void) -> s32 #foreign libc;

/** Not useful on Android; disallowed by SELinux. */
shmget :: (key: key_t, __size: u64, __flags: s32) -> s32 #foreign libc;

/** The information returned by uname(). */
utsname :: struct {
    /** The OS name. "Linux" on Android. */
    sysname:    [65] u8;

    /** The name on the network. Typically "localhost" on Android. */
    nodename:   [65] u8;

    /** The OS release. Typically something like "4.4.115-g442ad7fba0d" on Android. */
    release:    [65] u8;

    /** The OS version. Typically something like "#1 SMP PREEMPT" on Android. */
    version:    [65] u8;

    /** The hardware architecture. Typically "aarch64" on Android. */
    machine:    [65] u8;

    /** The domain name set by setdomainname(). Typically "localdomain" on Android. */
    domainname: [65] u8;
}

/**
* [uname(2)](http://man7.org/linux/man-pages/man2/uname.2.html) returns information
* about the kernel.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
uname :: (__buf: *utsname) -> s32 #foreign libc;

wait :: (__status: *s32) -> pid_t #foreign libc;
waitpid :: (__pid: pid_t, __status: *s32, __options: s32) -> pid_t #foreign libc;

wait4 :: (__pid: pid_t, __status: *s32, __options: s32, __rusage: *rusage) -> pid_t #foreign libc;

/* Posix states that idtype_t should be an enumeration type, but
* the kernel headers define P_ALL, P_PID and P_PGID as constant macros
* instead.
*/
idtype_t :: s32;

waitid :: (__type: idtype_t, __id: id_t, __info: *siginfo_t, __options: s32) -> s32 #foreign libc;

#scope_file

#import "Basic"; // For U128/S128

libc :: #library,system "libc";
libdl :: #library,system "libdl";
