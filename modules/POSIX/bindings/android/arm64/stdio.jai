//
// This file was auto-generated using the following command:
//
// jai modules/POSIX/generate.jai - -android -arm64
//



_GNU_SOURCE :: 1;
_IOFBF :: 0;
_IOLBF :: 1;
_IONBF :: 2;

BUFSIZ :: 1024;
EOF :: -1;

FOPEN_MAX :: 20;
FILENAME_MAX :: 4096;

L_tmpnam :: 4096;
TMP_MAX :: 308915776;

P_tmpdir :: "/tmp/";

RENAME_NOREPLACE :: 1<<0;

RENAME_EXCHANGE :: 1<<1;

RENAME_WHITEOUT :: 1<<2;

L_ctermid :: 1024;

O_DIRECTORY :: 0x4000 /* 040000 */;
O_NOFOLLOW :: 0x8000 /* 0100000 */;
O_DIRECT :: 0x10000 /* 0200000 */;
O_LARGEFILE :: 0x20000 /* 0400000 */;

O_ACCMODE :: 0x3 /* 00000003 */;
O_RDONLY :: 0x0 /* 00000000 */;
O_WRONLY :: 0x1 /* 00000001 */;
O_RDWR :: 0x2 /* 00000002 */;

O_CREAT :: 0x40 /* 00000100 */;

O_EXCL :: 0x80 /* 00000200 */;

O_NOCTTY :: 0x100 /* 00000400 */;

O_TRUNC :: 0x200 /* 00001000 */;

O_APPEND :: 0x400 /* 00002000 */;

O_NONBLOCK :: 0x800 /* 00004000 */;

O_DSYNC :: 0x1000 /* 00010000 */;

FASYNC :: 0x2000 /* 00020000 */;

O_NOATIME :: 0x40000 /* 01000000 */;

O_CLOEXEC :: 0x80000 /* 02000000 */;

__O_SYNC :: 0x100000 /* 04000000 */;
O_SYNC :: __O_SYNC | O_DSYNC;

O_PATH :: 0x200000 /* 010000000 */;

__O_TMPFILE :: 0x400000 /* 020000000 */;

O_TMPFILE :: __O_TMPFILE | O_DIRECTORY;
O_TMPFILE_MASK :: __O_TMPFILE | O_DIRECTORY | O_CREAT;

O_NDELAY :: O_NONBLOCK;

F_DUPFD :: 0;
F_GETFD :: 1;
F_SETFD :: 2;
F_GETFL :: 3;
F_SETFL :: 4;

F_GETLK :: 5;
F_SETLK :: 6;
F_SETLKW :: 7;

F_SETOWN :: 8;
F_GETOWN :: 9;

F_SETSIG :: 10;
F_GETSIG :: 11;

F_SETOWN_EX :: 15;
F_GETOWN_EX :: 16;

F_GETOWNER_UIDS :: 17;

F_OFD_GETLK :: 36;
F_OFD_SETLK :: 37;
F_OFD_SETLKW :: 38;
F_OWNER_TID :: 0;
F_OWNER_PID :: 1;
F_OWNER_PGRP :: 2;

FD_CLOEXEC :: 1;

F_RDLCK :: 0;
F_WRLCK :: 1;
F_UNLCK :: 2;

F_EXLCK :: 4;
F_SHLCK :: 8;

LOCK_SH :: 1;
LOCK_EX :: 2;
LOCK_NB :: 4;
LOCK_UN :: 8;
LOCK_MAND :: 32;
LOCK_READ :: 64;
LOCK_WRITE :: 128;
LOCK_RW :: 192;
F_LINUX_SPECIFIC_BASE :: 1024;

F_SETLEASE :: F_LINUX_SPECIFIC_BASE + 0;
F_GETLEASE :: F_LINUX_SPECIFIC_BASE + 1;
F_CANCELLK :: F_LINUX_SPECIFIC_BASE + 5;
F_DUPFD_CLOEXEC :: F_LINUX_SPECIFIC_BASE + 6;
F_NOTIFY :: F_LINUX_SPECIFIC_BASE + 2;
F_SETPIPE_SZ :: F_LINUX_SPECIFIC_BASE + 7;
F_GETPIPE_SZ :: F_LINUX_SPECIFIC_BASE + 8;
F_ADD_SEALS :: F_LINUX_SPECIFIC_BASE + 9;
F_GET_SEALS :: F_LINUX_SPECIFIC_BASE + 10;
F_SEAL_SEAL :: 0x0001;
F_SEAL_SHRINK :: 0x0002;
F_SEAL_GROW :: 0x0004;
F_SEAL_WRITE :: 0x0008;
F_SEAL_FUTURE_WRITE :: 0x0010;
F_SEAL_EXEC :: 0x0020;
F_GET_RW_HINT :: F_LINUX_SPECIFIC_BASE + 11;
F_SET_RW_HINT :: F_LINUX_SPECIFIC_BASE + 12;
F_GET_FILE_RW_HINT :: F_LINUX_SPECIFIC_BASE + 13;
F_SET_FILE_RW_HINT :: F_LINUX_SPECIFIC_BASE + 14;
RWH_WRITE_LIFE_NOT_SET :: 0;
RWH_WRITE_LIFE_NONE :: 1;
RWH_WRITE_LIFE_SHORT :: 2;
RWH_WRITE_LIFE_MEDIUM :: 3;
RWH_WRITE_LIFE_LONG :: 4;
RWH_WRITE_LIFE_EXTREME :: 5;
RWF_WRITE_LIFE_NOT_SET :: RWH_WRITE_LIFE_NOT_SET;
DN_ACCESS :: 0x00000001;
DN_MODIFY :: 0x00000002;
DN_CREATE :: 0x00000004;
DN_DELETE :: 0x00000008;
DN_RENAME :: 0x00000010;
DN_ATTRIB :: 0x00000020;
DN_MULTISHOT :: 0x80000000;
AT_FDCWD :: - 100;
AT_SYMLINK_NOFOLLOW :: 0x100;
AT_EACCESS :: 0x200;
AT_REMOVEDIR :: 0x200;
AT_SYMLINK_FOLLOW :: 0x400;
AT_NO_AUTOMOUNT :: 0x800;
AT_EMPTY_PATH :: 0x1000;
AT_STATX_SYNC_TYPE :: 0x6000;
AT_STATX_SYNC_AS_STAT :: 0x0000;
AT_STATX_FORCE_SYNC :: 0x2000;
AT_STATX_DONT_SYNC :: 0x4000;
AT_RECURSIVE :: 0x8000;

S_IFMT :: 0xf000 /* 00170000 */;
S_IFSOCK :: 0xc000 /* 0140000 */;
S_IFLNK :: 0xa000 /* 0120000 */;
S_IFREG :: 0x8000 /* 0100000 */;
S_IFBLK :: 0x6000 /* 0060000 */;
S_IFDIR :: 0x4000 /* 0040000 */;
S_IFCHR :: 0x2000 /* 0020000 */;
S_IFIFO :: 0x1000 /* 0010000 */;
S_ISUID :: 0x800 /* 0004000 */;
S_ISGID :: 0x400 /* 0002000 */;
S_ISVTX :: 0x200 /* 0001000 */;

S_IRWXU :: 0x1c0 /* 00700 */;
S_IRUSR :: 0x100 /* 00400 */;
S_IWUSR :: 0x80 /* 00200 */;
S_IXUSR :: 0x40 /* 00100 */;
S_IRWXG :: 0x38 /* 00070 */;
S_IRGRP :: 0x20 /* 00040 */;
S_IWGRP :: 0x10 /* 00020 */;
S_IXGRP :: 0x8 /* 00010 */;
S_IRWXO :: 0x7 /* 00007 */;
S_IROTH :: 0x4 /* 00004 */;
S_IWOTH :: 0x2 /* 00002 */;
S_IXOTH :: 0x1 /* 00001 */;

STATX_TYPE :: 0x00000001;
STATX_MODE :: 0x00000002;
STATX_NLINK :: 0x00000004;
STATX_UID :: 0x00000008;
STATX_GID :: 0x00000010;
STATX_ATIME :: 0x00000020;
STATX_MTIME :: 0x00000040;
STATX_CTIME :: 0x00000080;
STATX_INO :: 0x00000100;
STATX_SIZE :: 0x00000200;
STATX_BLOCKS :: 0x00000400;
STATX_BASIC_STATS :: 0x000007ff;
STATX_BTIME :: 0x00000800;
STATX_MNT_ID :: 0x00001000;
STATX_DIOALIGN :: 0x00002000;
STATX__RESERVED :: 0x80000000;
STATX_ALL :: 0x00000fff;
STATX_ATTR_COMPRESSED :: 0x00000004;
STATX_ATTR_IMMUTABLE :: 0x00000010;
STATX_ATTR_APPEND :: 0x00000020;
STATX_ATTR_NODUMP :: 0x00000040;
STATX_ATTR_ENCRYPTED :: 0x00000800;
STATX_ATTR_AUTOMOUNT :: 0x00001000;
STATX_ATTR_MOUNT_ROOT :: 0x00002000;
STATX_ATTR_VERITY :: 0x00100000;
STATX_ATTR_DAX :: 0x00200000;

F_GETLK64 :: F_GETLK;

F_SETLK64 :: F_SETLK;

F_SETLKW64 :: F_SETLKW;

O_ASYNC :: FASYNC;

O_RSYNC :: O_SYNC;

SPLICE_F_MOVE :: 1;

SPLICE_F_NONBLOCK :: 2;

SPLICE_F_MORE :: 4;

SPLICE_F_GIFT :: 8;

SYNC_FILE_RANGE_WAIT_BEFORE :: 1;

SYNC_FILE_RANGE_WRITE :: 2;

SYNC_FILE_RANGE_WAIT_AFTER :: 4;

ACCESSPERMS :: S_IRWXU | S_IRWXG | S_IRWXO;
ALLPERMS :: S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO;
DEFFILEMODE :: S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;

S_IREAD :: S_IRUSR;
S_IWRITE :: S_IWUSR;
S_IEXEC :: S_IXUSR;

UTIME_NOW :: (1 << 30) - 1;

UTIME_OMIT :: (1 << 30) - 2;

TCGETS :: 0x5401;
TCSETS :: 0x5402;
TCSETSW :: 0x5403;
TCSETSF :: 0x5404;
TCGETA :: 0x5405;
TCSETA :: 0x5406;
TCSETAW :: 0x5407;
TCSETAF :: 0x5408;
TCSBRK :: 0x5409;
TCXONC :: 0x540A;
TCFLSH :: 0x540B;
TIOCEXCL :: 0x540C;
TIOCNXCL :: 0x540D;
TIOCSCTTY :: 0x540E;
TIOCGPGRP :: 0x540F;
TIOCSPGRP :: 0x5410;
TIOCOUTQ :: 0x5411;
TIOCSTI :: 0x5412;
TIOCGWINSZ :: 0x5413;
TIOCSWINSZ :: 0x5414;
TIOCMGET :: 0x5415;
TIOCMBIS :: 0x5416;
TIOCMBIC :: 0x5417;
TIOCMSET :: 0x5418;
TIOCGSOFTCAR :: 0x5419;
TIOCSSOFTCAR :: 0x541A;
FIONREAD :: 0x541B;
TIOCINQ :: FIONREAD;
TIOCLINUX :: 0x541C;
TIOCCONS :: 0x541D;
TIOCGSERIAL :: 0x541E;
TIOCSSERIAL :: 0x541F;
TIOCPKT :: 0x5420;
FIONBIO :: 0x5421;
TIOCNOTTY :: 0x5422;
TIOCSETD :: 0x5423;
TIOCGETD :: 0x5424;
TCSBRKP :: 0x5425;
TIOCSBRK :: 0x5427;
TIOCCBRK :: 0x5428;
TIOCGSID :: 0x5429;

TIOCGRS485 :: 0x542E;

TIOCSRS485 :: 0x542F;

TCGETX :: 0x5432;
TCSETX :: 0x5433;
TCSETXF :: 0x5434;
TCSETXW :: 0x5435;

TIOCVHANGUP :: 0x5437;

FIONCLEX :: 0x5450;
FIOCLEX :: 0x5451;
FIOASYNC :: 0x5452;
TIOCSERCONFIG :: 0x5453;
TIOCSERGWILD :: 0x5454;
TIOCSERSWILD :: 0x5455;
TIOCGLCKTRMIOS :: 0x5456;
TIOCSLCKTRMIOS :: 0x5457;
TIOCSERGSTRUCT :: 0x5458;
TIOCSERGETLSR :: 0x5459;
TIOCSERGETMULTI :: 0x545A;
TIOCSERSETMULTI :: 0x545B;
TIOCMIWAIT :: 0x545C;
TIOCGICOUNT :: 0x545D;

FIOQSIZE :: 0x5460;

TIOCPKT_DATA :: 0;
TIOCPKT_FLUSHREAD :: 1;
TIOCPKT_FLUSHWRITE :: 2;
TIOCPKT_STOP :: 4;
TIOCPKT_START :: 8;
TIOCPKT_NOSTOP :: 16;
TIOCPKT_DOSTOP :: 32;
TIOCPKT_IOCTL :: 64;
TIOCSER_TEMT :: 0x01;

EFD_SEMAPHORE :: 1 << 0;

EFD_CLOEXEC :: O_CLOEXEC;

EFD_NONBLOCK :: O_NONBLOCK;

TFD_CLOEXEC :: O_CLOEXEC;

TFD_NONBLOCK :: O_NONBLOCK;

TFD_TIMER_ABSTIME :: 1 << 0;

TFD_TIMER_CANCEL_ON_SET :: 1 << 1;

SFD_CLOEXEC :: O_CLOEXEC;
SFD_NONBLOCK :: O_NONBLOCK;

fpos_t :: s64;
fpos64_t :: s64;

__sFILE :: struct {}
FILE :: __sFILE;

stdin: *FILE #elsewhere libc;
stdout: *FILE #elsewhere libc;
stderr: *FILE #elsewhere libc;

clearerr :: (__fp: *FILE) -> void #foreign libc;
fclose :: (__fp: *FILE) -> s32 #foreign libc;
feof :: (__fp: *FILE) -> s32 #foreign libc;
ferror :: (__fp: *FILE) -> s32 #foreign libc;
fflush :: (__fp: *FILE) -> s32 #foreign libc;
fgetc :: (__fp: *FILE) -> s32 #foreign libc;
fgets :: (__buf: *u8, __size: s32, __fp: *FILE) -> *u8 #foreign libc;
fprintf :: (__fp: *FILE, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
fputc :: (__ch: s32, __fp: *FILE) -> s32 #foreign libc;
fputs :: (__s: *u8, __fp: *FILE) -> s32 #foreign libc;
fread :: (__buf: *void, __size: u64, __count: u64, __fp: *FILE) -> u64 #foreign libc;
fscanf :: (__fp: *FILE, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
fwrite :: (__buf: *void, __size: u64, __count: u64, __fp: *FILE) -> u64 #foreign libc;
getc :: (__fp: *FILE) -> s32 #foreign libc;
getchar :: () -> s32 #foreign libc;

getdelim :: (__line_ptr: **u8, __line_length_ptr: *u64, __delimiter: s32, __fp: *FILE) -> s64 #foreign libc;
getline :: (__line_ptr: **u8, __line_length_ptr: *u64, __fp: *FILE) -> s64 #foreign libc;

perror :: (__msg: *u8) -> void #foreign libc;
printf :: (__fmt: *u8, __args: ..Any) -> s32 #foreign libc;
putc :: (__ch: s32, __fp: *FILE) -> s32 #foreign libc;
putchar :: (__ch: s32) -> s32 #foreign libc;
puts :: (__s: *u8) -> s32 #foreign libc;
_remove :: (__path: *u8) -> s32 #foreign libc "remove";
rewind :: (__fp: *FILE) -> void #foreign libc;
scanf :: (__fmt: *u8, __args: ..Any) -> s32 #foreign libc;
setbuf :: (__fp: *FILE, __buf: *u8) -> void #foreign libc;
setvbuf :: (__fp: *FILE, __buf: *u8, __mode: s32, __size: u64) -> s32 #foreign libc;
sscanf :: (__s: *u8, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
ungetc :: (__ch: s32, __fp: *FILE) -> s32 #foreign libc;

dprintf :: (__fd: s32, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;

sprintf :: (__s: *u8, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;

tmpnam :: (__s: *u8) -> *u8 #foreign libc;

tempnam :: (__dir: *u8, __prefix: *u8) -> *u8 #foreign libc;

/**
* [rename(2)](http://man7.org/linux/man-pages/man2/rename.2.html) changes
* the name or location of a file.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
rename :: (__old_path: *u8, __new_path: *u8) -> s32 #foreign libc;

/**
* [renameat(2)](http://man7.org/linux/man-pages/man2/renameat.2.html) changes
* the name or location of a file, interpreting relative paths using an fd.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*/
renameat :: (__old_dir_fd: s32, __old_path: *u8, __new_dir_fd: s32, __new_path: *u8) -> s32 #foreign libc;

renameat2 :: (__old_dir_fd: s32, __old_path: *u8, __new_dir_fd: s32, __new_path: *u8, __flags: u32) -> s32 #foreign libc;

fseek :: (__fp: *FILE, __offset: s64, __whence: s32) -> s32 #foreign libc;
ftell :: (__fp: *FILE) -> s64 #foreign libc;

fgetpos :: (__fp: *FILE, __pos: *fpos_t) -> s32 #foreign libc;
fsetpos :: (__fp: *FILE, __pos: *fpos_t) -> s32 #foreign libc;
fseeko :: (__fp: *FILE, __offset: s64, __whence: s32) -> s32 #foreign libc;
ftello :: (__fp: *FILE) -> s64 #foreign libc;

/* If __read_fn and __write_fn are both nullptr, it will cause EINVAL */
funopen :: (__cookie: *void, __read_fn: #type (unknown0: *void, unknown1: *u8, unknown2: s32) -> s32 #c_call, __write_fn: #type (unknown0: *void, unknown1: *u8, unknown2: s32) -> s32 #c_call, __seek_fn: #type (unknown0: *void, unknown1: fpos_t, unknown2: s32) -> fpos_t #c_call, __close_fn: #type (unknown0: *void) -> s32 #c_call) -> *FILE #foreign libc;

fgetpos64 :: (__fp: *FILE, __pos: *fpos64_t) -> s32 #foreign libc;
fsetpos64 :: (__fp: *FILE, __pos: *fpos64_t) -> s32 #foreign libc;
fseeko64 :: (__fp: *FILE, __offset: s64, __whence: s32) -> s32 #foreign libc;
ftello64 :: (__fp: *FILE) -> s64 #foreign libc;

funopen64 :: (__cookie: *void, __read_fn: #type (unknown0: *void, unknown1: *u8, unknown2: s32) -> s32 #c_call, __write_fn: #type (unknown0: *void, unknown1: *u8, unknown2: s32) -> s32 #c_call, __seek_fn: #type (unknown0: *void, unknown1: fpos64_t, unknown2: s32) -> fpos64_t #c_call, __close_fn: #type (unknown0: *void) -> s32 #c_call) -> *FILE #foreign libc;

fopen :: (__path: *u8, __mode: *u8) -> *FILE #foreign libc;

fopen64 :: (__path: *u8, __mode: *u8) -> *FILE #foreign libc;

freopen :: (__path: *u8, __mode: *u8, __fp: *FILE) -> *FILE #foreign libc;

freopen64 :: (__path: *u8, __mode: *u8, __fp: *FILE) -> *FILE #foreign libc;

tmpfile :: () -> *FILE #foreign libc;

tmpfile64 :: () -> *FILE #foreign libc;

snprintf :: (__buf: *u8, __size: u64, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;

ctermid :: (__buf: *u8) -> *u8 #foreign libc;

fdopen :: (__fd: s32, __mode: *u8) -> *FILE #foreign libc;
fileno :: (__fp: *FILE) -> s32 #foreign libc;
pclose :: (__fp: *FILE) -> s32 #foreign libc;
popen :: (__command: *u8, __mode: *u8) -> *FILE #foreign libc;
flockfile :: (__fp: *FILE) -> void #foreign libc;
ftrylockfile :: (__fp: *FILE) -> s32 #foreign libc;
funlockfile :: (__fp: *FILE) -> void #foreign libc;
getc_unlocked :: (__fp: *FILE) -> s32 #foreign libc;
getchar_unlocked :: () -> s32 #foreign libc;
putc_unlocked :: (__ch: s32, __fp: *FILE) -> s32 #foreign libc;
putchar_unlocked :: (__ch: s32) -> s32 #foreign libc;

fmemopen :: (__buf: *void, __size: u64, __mode: *u8) -> *FILE #foreign libc;
open_memstream :: (__ptr: **u8, __size_ptr: *u64) -> *FILE #foreign libc;

asprintf :: (__s_ptr: **u8, __fmt: *u8, __args: ..Any) -> s32 #foreign libc;
fgetln :: (__fp: *FILE, __length_ptr: *u64) -> *u8 #foreign libc;
fpurge :: (__fp: *FILE) -> s32 #foreign libc;
setbuffer :: (__fp: *FILE, __buf: *u8, __size: s32) -> void #foreign libc;
setlinebuf :: (__fp: *FILE) -> s32 #foreign libc;

clearerr_unlocked :: (__fp: *FILE) -> void #foreign libc;
feof_unlocked :: (__fp: *FILE) -> s32 #foreign libc;
ferror_unlocked :: (__fp: *FILE) -> s32 #foreign libc;

fileno_unlocked :: (__fp: *FILE) -> s32 #foreign libc;

fflush_unlocked :: (__fp: *FILE) -> s32 #foreign libc;
fgetc_unlocked :: (__fp: *FILE) -> s32 #foreign libc;
fputc_unlocked :: (__ch: s32, __fp: *FILE) -> s32 #foreign libc;
fread_unlocked :: (__buf: *void, __size: u64, __count: u64, __fp: *FILE) -> u64 #foreign libc;
fwrite_unlocked :: (__buf: *void, __size: u64, __count: u64, __fp: *FILE) -> u64 #foreign libc;

fputs_unlocked :: (__s: *u8, __fp: *FILE) -> s32 #foreign libc;
fgets_unlocked :: (__buf: *u8, __size: s32, __fp: *FILE) -> *u8 #foreign libc;

f_owner_ex :: struct {
    type: s32;
    pid:  s32;
}

statx_timestamp :: struct {
    tv_sec:     s64;
    tv_nsec:    u32;
    __reserved: s32;
}

statx_t :: struct {
    stx_mask:             u32;
    stx_blksize:          u32;
    stx_attributes:       u64;
    stx_nlink:            u32;
    stx_uid:              u32;
    stx_gid:              u32;
    stx_mode:             u16;
    __spare0:             [1] u16;
    stx_ino:              u64;
    stx_size:             u64;
    stx_blocks:           u64;
    stx_attributes_mask:  u64;
    stx_atime:            statx_timestamp;
    stx_btime:            statx_timestamp;
    stx_ctime:            statx_timestamp;
    stx_mtime:            statx_timestamp;
    stx_rdev_major:       u32;
    stx_rdev_minor:       u32;
    stx_dev_major:        u32;
    stx_dev_minor:        u32;
    stx_mnt_id:           u64;
    stx_dio_mem_align:    u32;
    stx_dio_offset_align: u32;
    __spare3:             [12] u64;
}

fcntl :: (__fd: s32, __cmd: s32, __args: ..Any) -> s32 #foreign libc;

creat :: (__path: *u8, __mode: mode_t) -> s32 #foreign libc;

creat64 :: (__path: *u8, __mode: mode_t) -> s32 #foreign libc;

openat :: (__dir_fd: s32, __path: *u8, __flags: s32, __args: ..Any) -> s32 #foreign libc;

openat64 :: (__dir_fd: s32, __path: *u8, __flags: s32, __args: ..Any) -> s32 #foreign libc;

open :: (__path: *u8, __flags: s32, __args: ..Any) -> s32 #foreign libc;

open64 :: (__path: *u8, __flags: s32, __args: ..Any) -> s32 #foreign libc;

splice :: (__in_fd: s32, __in_offset: *s64, __out_fd: s32, __out_offset: *s64, __length: u64, __flags: u32) -> s64 #foreign libc;

tee :: (__in_fd: s32, __out_fd: s32, __length: u64, __flags: u32) -> s64 #foreign libc;

vmsplice :: (__fd: s32, __iov: *iovec, __count: u64, __flags: u32) -> s64 #foreign libc;

fallocate :: (__fd: s32, __mode: s32, __offset: s64, __length: s64) -> s32 #foreign libc;

fallocate64 :: (__fd: s32, __mode: s32, __offset: s64, __length: s64) -> s32 #foreign libc;

posix_fadvise :: (__fd: s32, __offset: s64, __length: s64, __advice: s32) -> s32 #foreign libc;

posix_fadvise64 :: (__fd: s32, __offset: s64, __length: s64, __advice: s32) -> s32 #foreign libc;

posix_fallocate :: (__fd: s32, __offset: s64, __length: s64) -> s32 #foreign libc;

posix_fallocate64 :: (__fd: s32, __offset: s64, __length: s64) -> s32 #foreign libc;

readahead :: (__fd: s32, __offset: s64, __length: u64) -> s64 #foreign libc;

sync_file_range :: (__fd: s32, __offset: s64, __length: s64, __flags: u32) -> s32 #foreign libc;

stat_t :: struct {
    st_dev:     dev_t;
    st_ino:     ino_t;
    st_mode:    mode_t;
    st_nlink:   nlink_t;
    st_uid:     uid_t;
    st_gid:     gid_t;
    st_rdev:    dev_t;
    __pad1:     u64;
    st_size:    s64;
    st_blksize: s32;
    __pad2:     s32;
    st_blocks:  s64;
    st_atime:   timespec;
    st_mtime:   timespec;
    st_ctime:   timespec;
    __unused4:  u32;
    __unused5:  u32;
}
stat64_t :: struct {
    st_dev:     dev_t;
    st_ino:     ino_t;
    st_mode:    mode_t;
    st_nlink:   nlink_t;
    st_uid:     uid_t;
    st_gid:     gid_t;
    st_rdev:    dev_t;
    __pad1:     u64;
    st_size:    s64;
    st_blksize: s32;
    __pad2:     s32;
    st_blocks:  s64;
    st_atime:   timespec;
    st_mtime:   timespec;
    st_ctime:   timespec;
    __unused4:  u32;
    __unused5:  u32;
}

chmod :: (__path: *u8, __mode: mode_t) -> s32 #foreign libc;
fchmod :: (__fd: s32, __mode: mode_t) -> s32 #foreign libc;
mkdir :: (__path: *u8, __mode: mode_t) -> s32 #foreign libc;

fstat :: (__fd: s32, __buf: *stat_t) -> s32 #foreign libc;
fstat64 :: (__fd: s32, __buf: *stat64_t) -> s32 #foreign libc;
fstatat :: (__dir_fd: s32, __path: *u8, __buf: *stat_t, __flags: s32) -> s32 #foreign libc;
fstatat64 :: (__dir_fd: s32, __path: *u8, __buf: *stat64_t, __flags: s32) -> s32 #foreign libc;
lstat :: (__path: *u8, __buf: *stat_t) -> s32 #foreign libc;
lstat64 :: (__path: *u8, __buf: *stat64_t) -> s32 #foreign libc;
stat :: (__path: *u8, __buf: *stat_t) -> s32 #foreign libc;
stat64 :: (__path: *u8, __buf: *stat64_t) -> s32 #foreign libc;

mknod :: (__path: *u8, __mode: mode_t, __dev: dev_t) -> s32 #foreign libc;
umask :: (__mask: mode_t) -> mode_t #foreign libc;

mkfifo :: (__path: *u8, __mode: mode_t) -> s32 #foreign libc;

mkfifoat :: (__dir_fd: s32, __path: *u8, __mode: mode_t) -> s32 #foreign libc;

fchmodat :: (__dir_fd: s32, __path: *u8, __mode: mode_t, __flags: s32) -> s32 #foreign libc;
mkdirat :: (__dir_fd: s32, __path: *u8, __mode: mode_t) -> s32 #foreign libc;

mknodat :: (__dir_fd: s32, __path: *u8, __mode: mode_t, __dev: dev_t) -> s32 #foreign libc;

/**
* [utimensat(2)](https://man7.org/linux/man-pages/man2/utimensat.2.html) sets
* file timestamps.
*
* Note: Linux supports `__path` being NULL (in which case `__dir_fd` need not
* be a directory), allowing futimens() to be implemented with utimensat().
* For normal use of utimensat(), though, `__path` should be non-null.
*
* `__times[0]` is the access time (atime), and `__times[1]` the last modification time (mtime).
* If `__times` is NULL, both times are set to the current time.
* See also UTIME_NOW and UTIME_OMIT.
*
* Returns 0 on success and returns -1 and sets `errno` on failure.
*/
utimensat :: (__dir_fd: s32, __path: *u8, __times: *[2] timespec, __flags: s32) -> s32 #foreign libc;

futimens :: (__fd: s32, __times: *[2] timespec) -> s32 #foreign libc;

statx :: (__dir_fd: s32, __path: *u8, __flags: s32, __mask: u32, __buf: *statx_t) -> s32 #foreign libc;

/**
* [eventfd(2)](http://man7.org/linux/man-pages/man2/eventfd.2.html) creates a file descriptor
* for event notification.
*
* Returns a new file descriptor on success, and returns -1 and sets `errno` on failure.
*/
eventfd :: (__initial_value: u32, __flags: s32) -> s32 #foreign libc;

/** The type used by eventfd_read() and eventfd_write(). */
eventfd_t :: u64;

/**
* [eventfd_read(3)](http://man7.org/linux/man-pages/man2/eventfd.2.html) is a convenience
* wrapper to read an `eventfd_t` from an eventfd file descriptor.
*
* Returns 0 on success, or returns -1 otherwise.
*/
eventfd_read :: (__fd: s32, __value: *eventfd_t) -> s32 #foreign libc;

/**
* [eventfd_write(3)](http://man7.org/linux/man-pages/man2/eventfd.2.html) is a convenience
* wrapper to write an `eventfd_t` to an eventfd file descriptor.
*
* Returns 0 on success, or returns -1 otherwise.
*/
eventfd_write :: (__fd: s32, __value: eventfd_t) -> s32 #foreign libc;

timerfd_create :: (__clock: clockid_t, __flags: s32) -> s32 #foreign libc;

timerfd_settime :: (__fd: s32, __flags: s32, __new_value: *itimerspec, __old_value: *itimerspec) -> s32 #foreign libc;

/**
* [timerfd_gettime(2)](http://man7.org/linux/man-pages/man2/timerfd_gettime.2.html) queries the
* current timer settings.
*
* Returns 0 on success, and returns -1 and sets `errno` on failure.
*
* Available since API level 19.
*/
timerfd_gettime :: (__fd: s32, __current_value: *itimerspec) -> s32 #foreign libc;

signalfd_siginfo :: struct {
    ssi_signo:     u32;
    ssi_errno:     s32;
    ssi_code:      s32;
    ssi_pid:       u32;
    ssi_uid:       u32;
    ssi_fd:        s32;
    ssi_tid:       u32;
    ssi_band:      u32;
    ssi_overrun:   u32;
    ssi_trapno:    u32;
    ssi_status:    s32;
    ssi_int:       s32;
    ssi_ptr:       u64;
    ssi_utime:     u64;
    ssi_stime:     u64;
    ssi_addr:      u64;
    ssi_addr_lsb:  u16;
    __pad2:        u16;
    ssi_syscall:   s32;
    ssi_call_addr: u64;
    ssi_arch:      u32;
    __pad:         [28] u8;
}

signalfd :: (__fd: s32, __mask: *sigset_t, __flags: s32) -> s32 #foreign libc;

signalfd64 :: (__fd: s32, __mask: *sigset64_t, __flags: s32) -> s32 #foreign libc;

#scope_file

libc :: #library,system "libc";
