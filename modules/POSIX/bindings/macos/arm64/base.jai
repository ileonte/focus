//
// This file was auto-generated using the following command:
//
// jai modules/POSIX/generate.jai - -arm64
//



RTLD_LAZY :: 0x1;
RTLD_NOW :: 0x2;
RTLD_LOCAL :: 0x4;
RTLD_GLOBAL :: 0x8;

RTLD_NOLOAD :: 0x10;
RTLD_NODELETE :: 0x80;
RTLD_FIRST :: 0x100;

RTLD_NEXT :: cast,trunc(*void) -1;
RTLD_DEFAULT :: cast,trunc(*void) -2;
RTLD_SELF :: cast,trunc(*void) -3;
RTLD_MAIN_ONLY :: cast,trunc(*void) -5;

__DARWIN_MAXNAMLEN :: 255;

__DARWIN_MAXPATHLEN :: 1024;

MAXNAMLEN :: __DARWIN_MAXNAMLEN;

DT :: enum u8 {
    UNKNOWN :: 0;
    FIFO    :: 1;
    CHR     :: 2;
    DIR     :: 4;
    BLK     :: 6;
    REG     :: 8;
    LNK     :: 10;
    SOCK    :: 12;
    WHT     :: 14;
}

DIRBLKSIZ :: 1024;

DTF_HIDEW :: 0x0001;
DTF_NODUP :: 0x0002;
DTF_REWIND :: 0x0004;
__DTF_READALL :: 0x0008;
__DTF_SKIPREAD :: 0x0010;
__DTF_ATEND :: 0x0020;

EPERM :: 1;
ENOENT :: 2;
ESRCH :: 3;
EINTR :: 4;
EIO :: 5;
ENXIO :: 6;
E2BIG :: 7;
ENOEXEC :: 8;
EBADF :: 9;
ECHILD :: 10;
EDEADLK :: 11;

ENOMEM :: 12;
EACCES :: 13;
EFAULT :: 14;

ENOTBLK :: 15;

EBUSY :: 16;
EEXIST :: 17;
EXDEV :: 18;
ENODEV :: 19;
ENOTDIR :: 20;
EISDIR :: 21;
EINVAL :: 22;
ENFILE :: 23;
EMFILE :: 24;
ENOTTY :: 25;
ETXTBSY :: 26;
EFBIG :: 27;
ENOSPC :: 28;
ESPIPE :: 29;
EROFS :: 30;
EMLINK :: 31;
EPIPE :: 32;

EDOM :: 33;
ERANGE :: 34;

EAGAIN :: 35;
EWOULDBLOCK :: EAGAIN;
EINPROGRESS :: 36;
EALREADY :: 37;

ENOTSOCK :: 38;
EDESTADDRREQ :: 39;
EMSGSIZE :: 40;
EPROTOTYPE :: 41;
ENOPROTOOPT :: 42;
EPROTONOSUPPORT :: 43;

ESOCKTNOSUPPORT :: 44;

ENOTSUP :: 45;

EPFNOSUPPORT :: 46;

EAFNOSUPPORT :: 47;
EADDRINUSE :: 48;
EADDRNOTAVAIL :: 49;

ENETDOWN :: 50;
ENETUNREACH :: 51;
ENETRESET :: 52;
ECONNABORTED :: 53;
ECONNRESET :: 54;
ENOBUFS :: 55;
EISCONN :: 56;
ENOTCONN :: 57;

ESHUTDOWN :: 58;
ETOOMANYREFS :: 59;

ETIMEDOUT :: 60;
ECONNREFUSED :: 61;

ELOOP :: 62;
ENAMETOOLONG :: 63;

EHOSTDOWN :: 64;

EHOSTUNREACH :: 65;
ENOTEMPTY :: 66;

EPROCLIM :: 67;
EUSERS :: 68;

EDQUOT :: 69;

ESTALE :: 70;

EREMOTE :: 71;
EBADRPC :: 72;
ERPCMISMATCH :: 73;
EPROGUNAVAIL :: 74;
EPROGMISMATCH :: 75;
EPROCUNAVAIL :: 76;

ENOLCK :: 77;
ENOSYS :: 78;

EFTYPE :: 79;
EAUTH :: 80;
ENEEDAUTH :: 81;

EPWROFF :: 82;
EDEVERR :: 83;

EOVERFLOW :: 84;

EBADEXEC :: 85;
EBADARCH :: 86;
ESHLIBVERS :: 87;
EBADMACHO :: 88;

ECANCELED :: 89;

EIDRM :: 90;
ENOMSG :: 91;
EILSEQ :: 92;

ENOATTR :: 93;

EBADMSG :: 94;
EMULTIHOP :: 95;
ENODATA :: 96;
ENOLINK :: 97;
ENOSR :: 98;
ENOSTR :: 99;
EPROTO :: 100;
ETIME :: 101;

EOPNOTSUPP :: 102;

ENOPOLICY :: 103;

ENOTRECOVERABLE :: 104;
EOWNERDEAD :: 105;

EQFULL :: 106;
ELAST :: 106;

FNM_NOMATCH :: 1;

FNM_NOESCAPE :: 0x01;
FNM_PATHNAME :: 0x02;
FNM_PERIOD :: 0x04;

FNM_NOSYS :: -1;

FNM_LEADING_DIR :: 0x08;
FNM_CASEFOLD :: 0x10;
FNM_IGNORECASE :: FNM_CASEFOLD;
FNM_FILE_NAME :: FNM_PATHNAME;

_PATH_PWD :: "/etc";
_PATH_PASSWD :: "/etc/passwd";
_PASSWD :: "passwd";
_PATH_MASTERPASSWD :: "/etc/master.passwd";
_PATH_MASTERPASSWD_LOCK :: "/etc/ptmp";
_MASTERPASSWD :: "master.passwd";

_PATH_MP_DB :: "/etc/pwd.db";
_MP_DB :: "pwd.db";
_PATH_SMP_DB :: "/etc/spwd.db";
_SMP_DB :: "spwd.db";

_PATH_PWD_MKDB :: "/usr/sbin/pwd_mkdb";

_PASSWORD_LEN :: 128;

_PASSWORD_NOUID :: 0x01;
_PASSWORD_NOGID :: 0x02;
_PASSWORD_NOCHG :: 0x04;
_PASSWORD_NOEXP :: 0x08;

_PASSWORD_WARNDAYS :: 14;
_PASSWORD_CHGNOW :: -1;

__DARWIN_NSIG :: 32;

NSIG :: __DARWIN_NSIG;

_ARM_SIGNAL_ :: 1;

SIGHUP :: 1;
SIGINT :: 2;
SIGQUIT :: 3;
SIGILL :: 4;
SIGTRAP :: 5;
SIGABRT :: 6;

SIGIOT :: SIGABRT;
SIGEMT :: 7;

SIGFPE :: 8;
SIGKILL :: 9;
SIGBUS :: 10;
SIGSEGV :: 11;
SIGSYS :: 12;
SIGPIPE :: 13;
SIGALRM :: 14;
SIGTERM :: 15;
SIGURG :: 16;
SIGSTOP :: 17;
SIGTSTP :: 18;
SIGCONT :: 19;
SIGCHLD :: 20;
SIGTTIN :: 21;
SIGTTOU :: 22;

SIGIO :: 23;

SIGXCPU :: 24;
SIGXFSZ :: 25;
SIGVTALRM :: 26;
SIGPROF :: 27;

SIGWINCH :: 28;
SIGINFO :: 29;

SIGUSR1 :: 30;
SIGUSR2 :: 31;

SIG_DFL :: cast(*void) 0;
SIG_IGN :: cast(*void) 1;
SIG_HOLD :: cast(*void) 5;
SIG_ERR :: cast(*void) -1;

__DARWIN_OPAQUE_ARM_THREAD_STATE64 :: 0;

SIGEV_NONE :: 0;
SIGEV_SIGNAL :: 1;
SIGEV_THREAD :: 3;

ILL_NOOP :: 0;

ILL_ILLOPC :: 1;
ILL_ILLTRP :: 2;
ILL_PRVOPC :: 3;
ILL_ILLOPN :: 4;
ILL_ILLADR :: 5;
ILL_PRVREG :: 6;
ILL_COPROC :: 7;
ILL_BADSTK :: 8;

FPE_NOOP :: 0;

FPE_FLTDIV :: 1;
FPE_FLTOVF :: 2;
FPE_FLTUND :: 3;
FPE_FLTRES :: 4;
FPE_FLTINV :: 5;
FPE_FLTSUB :: 6;
FPE_INTDIV :: 7;
FPE_INTOVF :: 8;

SEGV_NOOP :: 0;

SEGV_MAPERR :: 1;
SEGV_ACCERR :: 2;

BUS_NOOP :: 0;

BUS_ADRALN :: 1;
BUS_ADRERR :: 2;
BUS_OBJERR :: 3;

TRAP_BRKPT :: 1;
TRAP_TRACE :: 2;

CLD_NOOP :: 0;

CLD_EXITED :: 1;
CLD_KILLED :: 2;
CLD_DUMPED :: 3;
CLD_TRAPPED :: 4;
CLD_STOPPED :: 5;
CLD_CONTINUED :: 6;

POLL_IN :: 1;
POLL_OUT :: 2;
POLL_MSG :: 3;
POLL_ERR :: 4;
POLL_PRI :: 5;
POLL_HUP :: 6;

SA_ONSTACK :: 0x0001;
SA_RESTART :: 0x0002;
SA_RESETHAND :: 0x0004;
SA_NOCLDSTOP :: 0x0008;
SA_NODEFER :: 0x0010;
SA_NOCLDWAIT :: 0x0020;
SA_SIGINFO :: 0x0040;

SA_USERTRAMP :: 0x0100;

SA_64REGSET :: 0x0200;

SA_USERSPACE_MASK :: SA_ONSTACK | SA_RESTART | SA_RESETHAND | SA_NOCLDSTOP | SA_NODEFER | SA_NOCLDWAIT | SA_SIGINFO;

SIG_BLOCK :: 1;
SIG_UNBLOCK :: 2;
SIG_SETMASK :: 3;

SI_USER :: 0x10001;
SI_QUEUE :: 0x10002;
SI_TIMER :: 0x10003;
SI_ASYNCIO :: 0x10004;
SI_MESGQ :: 0x10005;

SS_ONSTACK :: 0x0001;
SS_DISABLE :: 0x0004;
MINSIGSTKSZ :: 32768;
SIGSTKSZ :: 131072;

SV_ONSTACK :: SA_ONSTACK;
SV_INTERRUPT :: SA_RESTART;
SV_RESETHAND :: SA_RESETHAND;
SV_NODEFER :: SA_NODEFER;
SV_NOCLDSTOP :: SA_NOCLDSTOP;
SV_SIGINFO :: SA_SIGINFO;

BADSIG :: SIG_ERR;

__ipc_perm_new :: ipc_perm;

IPC_CREAT :: 0x200 /* 001000 */;
IPC_EXCL :: 0x400 /* 002000 */;
IPC_NOWAIT :: 0x800 /* 004000 */;

IPC_PRIVATE :: cast(key_t) 0;

IPC_RMID :: 0;
IPC_SET :: 1;
IPC_STAT :: 2;

IPC_R :: 0x100 /* 000400 */;
IPC_W :: 0x80 /* 000200 */;
IPC_M :: 0x1000 /* 010000 */;

PROT_NONE :: 0x00;
PROT_READ :: 0x01;
PROT_WRITE :: 0x02;
PROT_EXEC :: 0x04;

MAP_SHARED :: 0x0001;
MAP_PRIVATE :: 0x0002;

MAP_COPY :: MAP_PRIVATE;

MAP_FIXED :: 0x0010;

MAP_RENAME :: 0x0020;
MAP_NORESERVE :: 0x0040;
MAP_RESERVED0080 :: 0x0080;
MAP_NOEXTEND :: 0x0100;
MAP_HASSEMAPHORE :: 0x0200;
MAP_NOCACHE :: 0x0400;
MAP_JIT :: 0x0800;

MAP_FILE :: 0x0000;
MAP_ANON :: 0x1000;
MAP_ANONYMOUS :: MAP_ANON;

MAP_RESILIENT_CODESIGN :: 0x2000;
MAP_RESILIENT_MEDIA :: 0x4000;

MAP_32BIT :: 0x8000;

MAP_TRANSLATED_ALLOW_EXECUTE :: 0x20000;

MAP_UNIX03 :: 0x40000;

MCL_CURRENT :: 0x0001;
MCL_FUTURE :: 0x0002;

MAP_FAILED :: cast,trunc(*void) -1;

MS_ASYNC :: 0x0001;
MS_INVALIDATE :: 0x0002;
MS_SYNC :: 0x0010;

MS_KILLPAGES :: 0x0004;
MS_DEACTIVATE :: 0x0008;

MADV_NORMAL :: 0;
MADV_RANDOM :: 1;
MADV_SEQUENTIAL :: 2;
MADV_WILLNEED :: 3;
MADV_DONTNEED :: 4;
MADV_FREE :: 5;
MADV_ZERO_WIRED_PAGES :: 6;
MADV_FREE_REUSABLE :: 7;
MADV_FREE_REUSE :: 8;
MADV_CAN_REUSE :: 9;
MADV_PAGEOUT :: 10;

MINCORE_INCORE :: 0x1;
MINCORE_REFERENCED :: 0x2;
MINCORE_MODIFIED :: 0x4;
MINCORE_REFERENCED_OTHER :: 0x8;
MINCORE_MODIFIED_OTHER :: 0x10;
MINCORE_PAGED_OUT :: 0x20;
MINCORE_COPIED :: 0x40;
MINCORE_ANONYMOUS :: 0x80;

POLLIN :: 0x0001;
POLLPRI :: 0x0002;
POLLOUT :: 0x0004;
POLLRDNORM :: 0x0040;
POLLWRNORM :: POLLOUT;
POLLRDBAND :: 0x0080;
POLLWRBAND :: 0x0100;

POLLEXTEND :: 0x0200;
POLLATTRIB :: 0x0400;
POLLNLINK :: 0x0800;
POLLWRITE :: 0x1000;

POLLERR :: 0x0008;
POLLHUP :: 0x0010;
POLLNVAL :: 0x0020;

POLLSTANDARD :: POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND| POLLWRBAND|POLLERR|POLLHUP|POLLNVAL;

SHM_RDONLY :: 0x1000 /* 010000 */;
SHM_RND :: 0x2000 /* 020000 */;

SHMLBA :: 16*1024;

SHM_R :: IPC_R;
SHM_W :: IPC_W;

shmid_ds :: __shmid_ds_new;

ITIMER_REAL :: 0;
ITIMER_VIRTUAL :: 1;
ITIMER_PROF :: 2;

DST_NONE :: 0;
DST_USA :: 1;
DST_AUST :: 2;
DST_WET :: 3;
DST_MET :: 4;
DST_EET :: 5;
DST_CAN :: 6;

CLOCKS_PER_SEC :: 1000000;

TIME_UTC :: 1;

_SYS_NAMELEN :: 256;

WNOHANG :: 0x00000001;
WUNTRACED :: 0x00000002;

WCOREFLAG :: 0x80 /* 0200 */;

_WSTOPPED :: 0x7f /* 0177 */;

WEXITED :: 0x00000004;

WSTOPPED :: 0x00000008;

WCONTINUED :: 0x00000010;
WNOWAIT :: 0x00000020;

WAIT_ANY :: -1;
WAIT_MYPGRP :: 0;

F_OK :: 0;
X_OK :: 1<<0;
W_OK :: 1<<1;
R_OK :: 1<<2;

_READ_OK :: 1<<9;
_WRITE_OK :: 1<<10;
_EXECUTE_OK :: 1<<11;
_DELETE_OK :: 1<<12;
_APPEND_OK :: 1<<13;
_RMFILE_OK :: 1<<14;
_RATTR_OK :: 1<<15;
_WATTR_OK :: 1<<16;
_REXT_OK :: 1<<17;
_WEXT_OK :: 1<<18;
_RPERM_OK :: 1<<19;
_WPERM_OK :: 1<<20;
_CHOWN_OK :: 1<<21;

_ACCESS_EXTENDED_MASK :: _READ_OK | _WRITE_OK | _EXECUTE_OK | _DELETE_OK | _APPEND_OK | _RMFILE_OK | _REXT_OK | _WEXT_OK | _RATTR_OK | _WATTR_OK | _RPERM_OK | _WPERM_OK | _CHOWN_OK;

ACCESSX_MAX_DESCRIPTORS :: 100;
ACCESSX_MAX_TABLESIZE :: 16 * 1024;

PC :: enum u32 {
    LINK_MAX             :: 1;
    MAX_CANON            :: 2;
    MAX_INPUT            :: 3;
    NAME_MAX             :: 4;
    PATH_MAX             :: 5;
    PIPE_BUF             :: 6;
    CHOWN_RESTRICTED     :: 7;
    NO_TRUNC             :: 8;
    VDISABLE             :: 9;

    NAME_CHARS_MAX       :: 10;
    CASE_SENSITIVE       :: 11;
    CASE_PRESERVING      :: 12;
    EXTENDED_SECURITY_NP :: 13;
    AUTH_OPAQUE_NP       :: 14;

    _2_SYMLINKS          :: 15;
    ALLOC_SIZE_MIN       :: 16;
    ASYNC_IO             :: 17;
    FILESIZEBITS         :: 18;
    PRIO_IO              :: 19;
    REC_INCR_XFER_SIZE   :: 20;
    REC_MAX_XFER_SIZE    :: 21;
    REC_MIN_XFER_SIZE    :: 22;
    REC_XFER_ALIGN       :: 23;
    SYMLINK_MAX          :: 24;
    SYNC_IO              :: 25;
    XATTR_SIZE_BITS      :: 26;
    MIN_HOLE_SIZE        :: 27;
}

_CS_PATH :: 1;

STDIN_FILENO :: 0;
STDOUT_FILENO :: 1;
STDERR_FILENO :: 2;

_XOPEN_VERSION :: 600;
_XOPEN_XCU_VERSION :: 4;

__ILP32_OFF32 :: -1;
__ILP32_OFFBIG :: -1;

__LP64_OFF64 :: 1;
__LPBIG_OFFBIG :: 1;

_V6_ILP32_OFF32 :: __ILP32_OFF32;
_V6_ILP32_OFFBIG :: __ILP32_OFFBIG;
_V6_LP64_OFF64 :: __LP64_OFF64;
_V6_LPBIG_OFFBIG :: __LPBIG_OFFBIG;

_XBS5_ILP32_OFF32 :: __ILP32_OFF32;
_XBS5_ILP32_OFFBIG :: __ILP32_OFFBIG;
_XBS5_LP64_OFF64 :: __LP64_OFF64;
_XBS5_LPBIG_OFFBIG :: __LPBIG_OFFBIG;

_XOPEN_CRYPT :: 1;
_XOPEN_ENH_I18N :: 1;
_XOPEN_LEGACY :: -1;
_XOPEN_REALTIME :: -1;
_XOPEN_REALTIME_THREADS :: -1;
_XOPEN_SHM :: 1;
_XOPEN_STREAMS :: -1;
_XOPEN_UNIX :: 1;

using _SC_definitions :: enum s32 {
    _SC_ARG_MAX                      :: 1;
    _SC_CHILD_MAX                    :: 2;
    _SC_CLK_TCK                      :: 3;
    _SC_NGROUPS_MAX                  :: 4;
    _SC_OPEN_MAX                     :: 5;
    _SC_JOB_CONTROL                  :: 6;
    _SC_SAVED_IDS                    :: 7;
    _SC_VERSION                      :: 8;
    _SC_BC_BASE_MAX                  :: 9;
    _SC_BC_DIM_MAX                   :: 10;
    _SC_BC_SCALE_MAX                 :: 11;
    _SC_BC_STRING_MAX                :: 12;
    _SC_COLL_WEIGHTS_MAX             :: 13;
    _SC_EXPR_NEST_MAX                :: 14;
    _SC_LINE_MAX                     :: 15;
    _SC_RE_DUP_MAX                   :: 16;
    _SC_2_VERSION                    :: 17;
    _SC_2_C_BIND                     :: 18;
    _SC_2_C_DEV                      :: 19;
    _SC_2_CHAR_TERM                  :: 20;
    _SC_2_FORT_DEV                   :: 21;
    _SC_2_FORT_RUN                   :: 22;
    _SC_2_LOCALEDEF                  :: 23;
    _SC_2_SW_DEV                     :: 24;
    _SC_2_UPE                        :: 25;
    _SC_STREAM_MAX                   :: 26;
    _SC_TZNAME_MAX                   :: 27;

    _SC_ASYNCHRONOUS_IO              :: 28;
    _SC_PAGESIZE                     :: 29;
    _SC_MEMLOCK                      :: 30;
    _SC_MEMLOCK_RANGE                :: 31;
    _SC_MEMORY_PROTECTION            :: 32;
    _SC_MESSAGE_PASSING              :: 33;
    _SC_PRIORITIZED_IO               :: 34;
    _SC_PRIORITY_SCHEDULING          :: 35;
    _SC_REALTIME_SIGNALS             :: 36;
    _SC_SEMAPHORES                   :: 37;
    _SC_FSYNC                        :: 38;
    _SC_SHARED_MEMORY_OBJECTS        :: 39;
    _SC_SYNCHRONIZED_IO              :: 40;
    _SC_TIMERS                       :: 41;
    _SC_AIO_LISTIO_MAX               :: 42;
    _SC_AIO_MAX                      :: 43;
    _SC_AIO_PRIO_DELTA_MAX           :: 44;
    _SC_DELAYTIMER_MAX               :: 45;
    _SC_MQ_OPEN_MAX                  :: 46;
    _SC_MAPPED_FILES                 :: 47;
    _SC_RTSIG_MAX                    :: 48;
    _SC_SEM_NSEMS_MAX                :: 49;
    _SC_SEM_VALUE_MAX                :: 50;
    _SC_SIGQUEUE_MAX                 :: 51;
    _SC_TIMER_MAX                    :: 52;

    _SC_NPROCESSORS_CONF             :: 57;
    _SC_NPROCESSORS_ONLN             :: 58;

    _SC_2_PBS                        :: 59;
    _SC_2_PBS_ACCOUNTING             :: 60;
    _SC_2_PBS_CHECKPOINT             :: 61;
    _SC_2_PBS_LOCATE                 :: 62;
    _SC_2_PBS_MESSAGE                :: 63;
    _SC_2_PBS_TRACK                  :: 64;
    _SC_ADVISORY_INFO                :: 65;
    _SC_BARRIERS                     :: 66;
    _SC_CLOCK_SELECTION              :: 67;
    _SC_CPUTIME                      :: 68;
    _SC_FILE_LOCKING                 :: 69;
    _SC_GETGR_R_SIZE_MAX             :: 70;
    _SC_GETPW_R_SIZE_MAX             :: 71;
    _SC_HOST_NAME_MAX                :: 72;
    _SC_LOGIN_NAME_MAX               :: 73;
    _SC_MONOTONIC_CLOCK              :: 74;
    _SC_MQ_PRIO_MAX                  :: 75;
    _SC_READER_WRITER_LOCKS          :: 76;
    _SC_REGEXP                       :: 77;
    _SC_SHELL                        :: 78;
    _SC_SPAWN                        :: 79;
    _SC_SPIN_LOCKS                   :: 80;
    _SC_SPORADIC_SERVER              :: 81;
    _SC_THREAD_ATTR_STACKADDR        :: 82;
    _SC_THREAD_ATTR_STACKSIZE        :: 83;
    _SC_THREAD_CPUTIME               :: 84;
    _SC_THREAD_DESTRUCTOR_ITERATIONS :: 85;
    _SC_THREAD_KEYS_MAX              :: 86;
    _SC_THREAD_PRIO_INHERIT          :: 87;
    _SC_THREAD_PRIO_PROTECT          :: 88;
    _SC_THREAD_PRIORITY_SCHEDULING   :: 89;
    _SC_THREAD_PROCESS_SHARED        :: 90;
    _SC_THREAD_SAFE_FUNCTIONS        :: 91;
    _SC_THREAD_SPORADIC_SERVER       :: 92;
    _SC_THREAD_STACK_MIN             :: 93;
    _SC_THREAD_THREADS_MAX           :: 94;
    _SC_TIMEOUTS                     :: 95;
    _SC_THREADS                      :: 96;
    _SC_TRACE                        :: 97;
    _SC_TRACE_EVENT_FILTER           :: 98;
    _SC_TRACE_INHERIT                :: 99;
    _SC_TRACE_LOG                    :: 100;
    _SC_TTY_NAME_MAX                 :: 101;
    _SC_TYPED_MEMORY_OBJECTS         :: 102;
    _SC_V6_ILP32_OFF32               :: 103;
    _SC_V6_ILP32_OFFBIG              :: 104;
    _SC_V6_LP64_OFF64                :: 105;
    _SC_V6_LPBIG_OFFBIG              :: 106;
    _SC_IPV6                         :: 118;
    _SC_RAW_SOCKETS                  :: 119;
    _SC_SYMLOOP_MAX                  :: 120;

    _SC_ATEXIT_MAX                   :: 107;
    _SC_IOV_MAX                      :: 56;
    _SC_PAGE_SIZE                    :: _SC_PAGESIZE;
    _SC_XOPEN_CRYPT                  :: 108;
    _SC_XOPEN_ENH_I18N               :: 109;
    _SC_XOPEN_LEGACY                 :: 110;
    _SC_XOPEN_REALTIME               :: 111;
    _SC_XOPEN_REALTIME_THREADS       :: 112;
    _SC_XOPEN_SHM                    :: 113;
    _SC_XOPEN_STREAMS                :: 114;
    _SC_XOPEN_UNIX                   :: 115;
    _SC_XOPEN_VERSION                :: 116;
    _SC_XOPEN_XCU_VERSION            :: 121;

    _SC_XBS5_ILP32_OFF32             :: 122;
    _SC_XBS5_ILP32_OFFBIG            :: 123;
    _SC_XBS5_LP64_OFF64              :: 124;
    _SC_XBS5_LPBIG_OFFBIG            :: 125;

    _SC_SS_REPL_MAX                  :: 126;
    _SC_TRACE_EVENT_NAME_MAX         :: 127;
    _SC_TRACE_NAME_MAX               :: 128;
    _SC_TRACE_SYS_MAX                :: 129;
    _SC_TRACE_USER_EVENT_MAX         :: 130;

    _SC_PASS_MAX                     :: 131;

    _SC_PHYS_PAGES                   :: 200;
}

_CS_POSIX_V6_ILP32_OFF32_CFLAGS :: 2;
_CS_POSIX_V6_ILP32_OFF32_LDFLAGS :: 3;
_CS_POSIX_V6_ILP32_OFF32_LIBS :: 4;
_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS :: 5;
_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS :: 6;
_CS_POSIX_V6_ILP32_OFFBIG_LIBS :: 7;
_CS_POSIX_V6_LP64_OFF64_CFLAGS :: 8;
_CS_POSIX_V6_LP64_OFF64_LDFLAGS :: 9;
_CS_POSIX_V6_LP64_OFF64_LIBS :: 10;
_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS :: 11;
_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS :: 12;
_CS_POSIX_V6_LPBIG_OFFBIG_LIBS :: 13;
_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS :: 14;

_CS_XBS5_ILP32_OFF32_CFLAGS :: 20;
_CS_XBS5_ILP32_OFF32_LDFLAGS :: 21;
_CS_XBS5_ILP32_OFF32_LIBS :: 22;
_CS_XBS5_ILP32_OFF32_LINTFLAGS :: 23;
_CS_XBS5_ILP32_OFFBIG_CFLAGS :: 24;
_CS_XBS5_ILP32_OFFBIG_LDFLAGS :: 25;
_CS_XBS5_ILP32_OFFBIG_LIBS :: 26;
_CS_XBS5_ILP32_OFFBIG_LINTFLAGS :: 27;
_CS_XBS5_LP64_OFF64_CFLAGS :: 28;
_CS_XBS5_LP64_OFF64_LDFLAGS :: 29;
_CS_XBS5_LP64_OFF64_LIBS :: 30;
_CS_XBS5_LP64_OFF64_LINTFLAGS :: 31;
_CS_XBS5_LPBIG_OFFBIG_CFLAGS :: 32;
_CS_XBS5_LPBIG_OFFBIG_LDFLAGS :: 33;
_CS_XBS5_LPBIG_OFFBIG_LIBS :: 34;
_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS :: 35;

_CS_DARWIN_USER_DIR :: 65536;
_CS_DARWIN_USER_TEMP_DIR :: 65537;
_CS_DARWIN_USER_CACHE_DIR :: 65538;

F_ULOCK :: 0;
F_LOCK :: 1;
F_TLOCK :: 2;
F_TEST :: 3;

SYNC_VOLUME_FULLSYNC :: 0x01;
SYNC_VOLUME_WAIT :: 0x02;

FSOPT_NOFOLLOW :: 0x00000001;
FSOPT_NOINMEMUPDATE :: 0x00000002;
FSOPT_REPORT_FULLSIZE :: 0x00000004;

FSOPT_PACK_INVAL_ATTRS :: 0x00000008;

FSOPT_ATTR_CMN_EXTENDED :: 0x00000020;
FSOPT_RETURN_REALDEV :: 0x00000200;

SEARCHFS_MAX_SEARCHPARMS :: 4096;

ATTR_BIT_MAP_COUNT :: 5;

VOL_CAPABILITIES_FORMAT :: 0;
VOL_CAPABILITIES_INTERFACES :: 1;
VOL_CAPABILITIES_RESERVED1 :: 2;
VOL_CAPABILITIES_RESERVED2 :: 3;

ATTR_MAX_BUFFER :: 8192;

VOL_CAP_FMT_PERSISTENTOBJECTIDS :: 0x00000001;
VOL_CAP_FMT_SYMBOLICLINKS :: 0x00000002;
VOL_CAP_FMT_HARDLINKS :: 0x00000004;
VOL_CAP_FMT_JOURNAL :: 0x00000008;
VOL_CAP_FMT_JOURNAL_ACTIVE :: 0x00000010;
VOL_CAP_FMT_NO_ROOT_TIMES :: 0x00000020;
VOL_CAP_FMT_SPARSE_FILES :: 0x00000040;
VOL_CAP_FMT_ZERO_RUNS :: 0x00000080;
VOL_CAP_FMT_CASE_SENSITIVE :: 0x00000100;
VOL_CAP_FMT_CASE_PRESERVING :: 0x00000200;
VOL_CAP_FMT_FAST_STATFS :: 0x00000400;
VOL_CAP_FMT_2TB_FILESIZE :: 0x00000800;
VOL_CAP_FMT_OPENDENYMODES :: 0x00001000;
VOL_CAP_FMT_HIDDEN_FILES :: 0x00002000;
VOL_CAP_FMT_PATH_FROM_ID :: 0x00004000;
VOL_CAP_FMT_NO_VOLUME_SIZES :: 0x00008000;
VOL_CAP_FMT_DECMPFS_COMPRESSION :: 0x00010000;
VOL_CAP_FMT_64BIT_OBJECT_IDS :: 0x00020000;
VOL_CAP_FMT_DIR_HARDLINKS :: 0x00040000;
VOL_CAP_FMT_DOCUMENT_ID :: 0x00080000;
VOL_CAP_FMT_WRITE_GENERATION_COUNT :: 0x00100000;
VOL_CAP_FMT_NO_IMMUTABLE_FILES :: 0x00200000;
VOL_CAP_FMT_NO_PERMISSIONS :: 0x00400000;
VOL_CAP_FMT_SHARED_SPACE :: 0x00800000;
VOL_CAP_FMT_VOL_GROUPS :: 0x01000000;
VOL_CAP_FMT_SEALED :: 0x02000000;

VOL_CAP_INT_SEARCHFS :: 0x00000001;
VOL_CAP_INT_ATTRLIST :: 0x00000002;
VOL_CAP_INT_NFSEXPORT :: 0x00000004;
VOL_CAP_INT_READDIRATTR :: 0x00000008;
VOL_CAP_INT_EXCHANGEDATA :: 0x00000010;
VOL_CAP_INT_COPYFILE :: 0x00000020;
VOL_CAP_INT_ALLOCATE :: 0x00000040;
VOL_CAP_INT_VOL_RENAME :: 0x00000080;
VOL_CAP_INT_ADVLOCK :: 0x00000100;
VOL_CAP_INT_FLOCK :: 0x00000200;
VOL_CAP_INT_EXTENDED_SECURITY :: 0x00000400;
VOL_CAP_INT_USERACCESS :: 0x00000800;
VOL_CAP_INT_MANLOCK :: 0x00001000;
VOL_CAP_INT_NAMEDSTREAMS :: 0x00002000;
VOL_CAP_INT_EXTENDED_ATTR :: 0x00004000;
VOL_CAP_INT_CLONE :: 0x00010000;
VOL_CAP_INT_SNAPSHOT :: 0x00020000;
VOL_CAP_INT_RENAME_SWAP :: 0x00040000;
VOL_CAP_INT_RENAME_EXCL :: 0x00080000;
VOL_CAP_INT_RENAME_OPENFAIL :: 0x00100000;

ATTR_CMN :: enum u32 {
    NAME                   :: 0x00000001;
    DEVID                  :: 0x00000002;
    FSID                   :: 0x00000004;
    OBJTYPE                :: 0x00000008;
    OBJTAG                 :: 0x00000010;
    OBJID                  :: 0x00000020;
    OBJPERMANENTID         :: 0x00000040;
    PAROBJID               :: 0x00000080;
    SCRIPT                 :: 0x00000100;
    CRTIME                 :: 0x00000200;
    MODTIME                :: 0x00000400;
    CHGTIME                :: 0x00000800;
    ACCTIME                :: 0x00001000;
    BKUPTIME               :: 0x00002000;
    FNDRINFO               :: 0x00004000;
    OWNERID                :: 0x00008000;
    GRPID                  :: 0x00010000;
    ACCESSMASK             :: 0x00020000;
    FLAGS                  :: 0x00040000;

    GEN_COUNT              :: 0x00080000;
    DOCUMENT_ID            :: 0x00100000;

    USERACCESS             :: 0x00200000;
    EXTENDED_SECURITY      :: 0x00400000;
    UUID                   :: 0x00800000;
    GRPUUID                :: 0x01000000;
    FILEID                 :: 0x02000000;
    PARENTID               :: 0x04000000;
    FULLPATH               :: 0x08000000;
    ADDEDTIME              :: 0x10000000;
    ERROR                  :: 0x20000000;
    DATA_PROTECT_FLAGS     :: 0x40000000;

    RETURNED_ATTRS         :: 0x80000000;

    VALIDMASK              :: 0xFFFFFFFF;

    SETMASK                :: 0x51C7FF00;
    VOLSETMASK             :: 0x00006700;

    EXT_RELPATH            :: 0x00000004;
    EXT_PRIVATESIZE        :: 0x00000008;
    EXT_LINKID             :: 0x00000010;
    EXT_NOFIRMLINKPATH     :: 0x00000020;
    EXT_REALDEVID          :: 0x00000040;
    EXT_REALFSID           :: 0x00000080;
    EXT_CLONEID            :: 0x00000100;
    EXT_EXT_FLAGS          :: 0x00000200;
    EXT_RECURSIVE_GENCOUNT :: 0x00000400;

    EXT_VALIDMASK          :: 0x000007fc;
    EXT_SETMASK            :: 0x00000000;

    NAMEDATTRCOUNT         :: 0x00080000;
    NAMEDATTRLIST          :: 0x00100000;

    ATTR_CMN_NAME                  :: NAME;
    ATTR_CMN_DEVID                 :: DEVID;
    ATTR_CMN_FSID                  :: FSID;
    ATTR_CMN_OBJTYPE               :: OBJTYPE;
    ATTR_CMN_OBJTAG                :: OBJTAG;
    ATTR_CMN_OBJID                 :: OBJID;
    ATTR_CMN_OBJPERMANENTID        :: OBJPERMANENTID;
    ATTR_CMN_PAROBJID              :: PAROBJID;
    ATTR_CMN_SCRIPT                :: SCRIPT;
    ATTR_CMN_CRTIME                :: CRTIME;
    ATTR_CMN_MODTIME               :: MODTIME;
    ATTR_CMN_CHGTIME               :: CHGTIME;
    ATTR_CMN_ACCTIME               :: ACCTIME;
    ATTR_CMN_BKUPTIME              :: BKUPTIME;
    ATTR_CMN_FNDRINFO              :: FNDRINFO;
    ATTR_CMN_OWNERID               :: OWNERID;
    ATTR_CMN_GRPID                 :: GRPID;
    ATTR_CMN_ACCESSMASK            :: ACCESSMASK;
    ATTR_CMN_FLAGS                 :: FLAGS;

    ATTR_CMN_GEN_COUNT             :: GEN_COUNT;
    ATTR_CMN_DOCUMENT_ID           :: DOCUMENT_ID;

    ATTR_CMN_USERACCESS            :: USERACCESS;
    ATTR_CMN_EXTENDED_SECURITY     :: EXTENDED_SECURITY;
    ATTR_CMN_UUID                  :: UUID;
    ATTR_CMN_GRPUUID               :: GRPUUID;
    ATTR_CMN_FILEID                :: FILEID;
    ATTR_CMN_PARENTID              :: PARENTID;
    ATTR_CMN_FULLPATH              :: FULLPATH;
    ATTR_CMN_ADDEDTIME             :: ADDEDTIME;
    ATTR_CMN_ERROR                 :: ERROR;
    ATTR_CMN_DATA_PROTECT_FLAGS    :: DATA_PROTECT_FLAGS;

    ATTR_CMN_RETURNED_ATTRS        :: RETURNED_ATTRS;

    ATTR_CMN_VALIDMASK             :: VALIDMASK;

    ATTR_CMN_SETMASK               :: SETMASK;
    ATTR_CMN_VOLSETMASK            :: VOLSETMASK;

    ATTR_CMNEXT_RELPATH            :: EXT_RELPATH;
    ATTR_CMNEXT_PRIVATESIZE        :: EXT_PRIVATESIZE;
    ATTR_CMNEXT_LINKID             :: EXT_LINKID;
    ATTR_CMNEXT_NOFIRMLINKPATH     :: EXT_NOFIRMLINKPATH;
    ATTR_CMNEXT_REALDEVID          :: EXT_REALDEVID;
    ATTR_CMNEXT_REALFSID           :: EXT_REALFSID;
    ATTR_CMNEXT_CLONEID            :: EXT_CLONEID;
    ATTR_CMNEXT_EXT_FLAGS          :: EXT_EXT_FLAGS;
    ATTR_CMNEXT_RECURSIVE_GENCOUNT :: EXT_RECURSIVE_GENCOUNT;

    ATTR_CMNEXT_VALIDMASK          :: EXT_VALIDMASK;
    ATTR_CMNEXT_SETMASK            :: EXT_SETMASK;

    ATTR_CMN_NAMEDATTRCOUNT        :: NAMEDATTRCOUNT;
    ATTR_CMN_NAMEDATTRLIST         :: NAMEDATTRLIST;
}

ATTR_VOL :: enum {
    FSTYPE          :: 0x00000001;
    SIGNATURE       :: 0x00000002;
    SIZE            :: 0x00000004;
    SPACEFREE       :: 0x00000008;
    SPACEAVAIL      :: 0x00000010;
    MINALLOCATION   :: 0x00000020;
    ALLOCATIONCLUMP :: 0x00000040;
    IOBLOCKSIZE     :: 0x00000080;
    OBJCOUNT        :: 0x00000100;
    FILECOUNT       :: 0x00000200;
    DIRCOUNT        :: 0x00000400;
    MAXOBJCOUNT     :: 0x00000800;
    MOUNTPOINT      :: 0x00001000;
    NAME            :: 0x00002000;
    MOUNTFLAGS      :: 0x00004000;
    MOUNTEDDEVICE   :: 0x00008000;
    ENCODINGSUSED   :: 0x00010000;
    CAPABILITIES    :: 0x00020000;
    UUID            :: 0x00040000;
    QUOTA_SIZE      :: 0x10000000;
    RESERVED_SIZE   :: 0x20000000;
    ATTRIBUTES      :: 0x40000000;
    INFO            :: 0x80000000;

    VALIDMASK       :: 0xF007FFFF;

    SETMASK         :: 0x80002000;

    ATTR_VOL_FSTYPE          :: FSTYPE;
    ATTR_VOL_SIGNATURE       :: SIGNATURE;
    ATTR_VOL_SIZE            :: SIZE;
    ATTR_VOL_SPACEFREE       :: SPACEFREE;
    ATTR_VOL_SPACEAVAIL      :: SPACEAVAIL;
    ATTR_VOL_MINALLOCATION   :: MINALLOCATION;
    ATTR_VOL_ALLOCATIONCLUMP :: ALLOCATIONCLUMP;
    ATTR_VOL_IOBLOCKSIZE     :: IOBLOCKSIZE;
    ATTR_VOL_OBJCOUNT        :: OBJCOUNT;
    ATTR_VOL_FILECOUNT       :: FILECOUNT;
    ATTR_VOL_DIRCOUNT        :: DIRCOUNT;
    ATTR_VOL_MAXOBJCOUNT     :: MAXOBJCOUNT;
    ATTR_VOL_MOUNTPOINT      :: MOUNTPOINT;
    ATTR_VOL_NAME            :: NAME;
    ATTR_VOL_MOUNTFLAGS      :: MOUNTFLAGS;
    ATTR_VOL_MOUNTEDDEVICE   :: MOUNTEDDEVICE;
    ATTR_VOL_ENCODINGSUSED   :: ENCODINGSUSED;
    ATTR_VOL_CAPABILITIES    :: CAPABILITIES;
    ATTR_VOL_UUID            :: UUID;
    ATTR_VOL_QUOTA_SIZE      :: QUOTA_SIZE;
    ATTR_VOL_RESERVED_SIZE   :: RESERVED_SIZE;
    ATTR_VOL_ATTRIBUTES      :: ATTRIBUTES;
    ATTR_VOL_INFO            :: INFO;

    ATTR_VOL_VALIDMASK       :: VALIDMASK;

    ATTR_VOL_SETMASK         :: SETMASK;
}

ATTR_DIR :: enum {
    LINKCOUNT   :: 0x00000001;
    ENTRYCOUNT  :: 0x00000002;
    MOUNTSTATUS :: 0x00000004;
    ALLOCSIZE   :: 0x00000008;
    IOBLOCKSIZE :: 0x00000010;
    DATALENGTH  :: 0x00000020;

    VALIDMASK   :: 0x0000003f;
    SETMASK     :: 0x00000000;

    ATTR_DIR_LINKCOUNT   :: LINKCOUNT;
    ATTR_DIR_ENTRYCOUNT  :: ENTRYCOUNT;
    ATTR_DIR_MOUNTSTATUS :: MOUNTSTATUS;
    ATTR_DIR_ALLOCSIZE   :: ALLOCSIZE;
    ATTR_DIR_IOBLOCKSIZE :: IOBLOCKSIZE;
    ATTR_DIR_DATALENGTH  :: DATALENGTH;

    ATTR_DIR_VALIDMASK   :: VALIDMASK;
    ATTR_DIR_SETMASK     :: SETMASK;
}

DIR_MNTSTATUS_MNTPOINT :: 0x00000001;
DIR_MNTSTATUS_TRIGGER :: 0x00000002;

ATTR_FILE :: enum {
    LINKCOUNT     :: 0x00000001;
    TOTALSIZE     :: 0x00000002;
    ALLOCSIZE     :: 0x00000004;
    IOBLOCKSIZE   :: 0x00000008;
    DEVTYPE       :: 0x00000020;
    FORKCOUNT     :: 0x00000080;
    FORKLIST      :: 0x00000100;
    DATALENGTH    :: 0x00000200;
    DATAALLOCSIZE :: 0x00000400;
    RSRCLENGTH    :: 0x00001000;
    RSRCALLOCSIZE :: 0x00002000;

    VALIDMASK     :: 0x000037FF;

    SETMASK       :: 0x00000020;

    CLUMPSIZE     :: 0x00000010;
    FILETYPE      :: 0x00000040;
    DATAEXTENTS   :: 0x00000800;
    RSRCEXTENTS   :: 0x00004000;

    ATTR_FILE_LINKCOUNT     :: LINKCOUNT;
    ATTR_FILE_TOTALSIZE     :: TOTALSIZE;
    ATTR_FILE_ALLOCSIZE     :: ALLOCSIZE;
    ATTR_FILE_IOBLOCKSIZE   :: IOBLOCKSIZE;
    ATTR_FILE_DEVTYPE       :: DEVTYPE;
    ATTR_FILE_FORKCOUNT     :: FORKCOUNT;
    ATTR_FILE_FORKLIST      :: FORKLIST;
    ATTR_FILE_DATALENGTH    :: DATALENGTH;
    ATTR_FILE_DATAALLOCSIZE :: DATAALLOCSIZE;
    ATTR_FILE_RSRCLENGTH    :: RSRCLENGTH;
    ATTR_FILE_RSRCALLOCSIZE :: RSRCALLOCSIZE;

    ATTR_FILE_VALIDMASK     :: VALIDMASK;

    ATTR_FILE_SETMASK       :: SETMASK;

    ATTR_FILE_CLUMPSIZE     :: CLUMPSIZE;
    ATTR_FILE_FILETYPE      :: FILETYPE;
    ATTR_FILE_DATAEXTENTS   :: DATAEXTENTS;
    ATTR_FILE_RSRCEXTENTS   :: RSRCEXTENTS;
}

ATTR_FORK :: enum {
    TOTALSIZE :: 0x00000001;
    ALLOCSIZE :: 0x00000002;
    RESERVED  :: 0xffffffff;

    VALIDMASK :: 0x00000003;
    SETMASK   :: 0x00000000;

    ATTR_FORK_TOTALSIZE :: TOTALSIZE;
    ATTR_FORK_ALLOCSIZE :: ALLOCSIZE;
    ATTR_FORK_RESERVED  :: RESERVED;

    ATTR_FORK_VALIDMASK :: VALIDMASK;
    ATTR_FORK_SETMASK   :: SETMASK;
}

ATTR_BULK_REQUIRED :: xx ATTR_CMN.NAME | xx ATTR_CMN.RETURNED_ATTRS;

SRCHFS_START :: 0x00000001;
SRCHFS_MATCHPARTIALNAMES :: 0x00000002;
SRCHFS_MATCHDIRS :: 0x00000004;
SRCHFS_MATCHFILES :: 0x00000008;
SRCHFS_SKIPLINKS :: 0x00000010;
SRCHFS_SKIPINVISIBLE :: 0x00000020;
SRCHFS_SKIPPACKAGES :: 0x00000040;
SRCHFS_SKIPINAPPROPRIATE :: 0x00000080;

SRCHFS_NEGATEPARAMS :: 0x80000000;
SRCHFS_VALIDOPTIONSMASK :: 0x800000FF;

FST_EOF :: -1;

HAVE_VT_LOCKERFS :: 1;

VNODE_READ :: 0x01;
VNODE_WRITE :: 0x02;
VNODE_BLOCKMAP_NO_TRACK :: 0x04;

PREALLOCATE :: 0x00000001;
ALLOCATECONTIG :: 0x00000002;
ALLOCATEALL :: 0x00000004;

FREEREMAINDER :: 0x00000008;

ALLOCATEFROMPEOF :: 0x00000010;
ALLOCATEFROMVOL :: 0x00000020;

VNOVAL :: -1;

/*
* Structure filled in by dladdr().
*/
dl_info :: struct {
    dli_fname: *u8; /* Pathname of shared object */
    dli_fbase: *void; /* Base address of shared object */
    dli_sname: *u8; /* Name of nearest symbol */
    dli_saddr: *void; /* Address of nearest symbol */
}

/*
* Structure filled in by dladdr().
*/
Dl_info :: dl_info;

dladdr :: (unknown0: *void, unknown1: *Dl_info) -> s32 #foreign libc;

dlclose :: (__handle: *void) -> s32 #foreign libc;
dlerror :: () -> *u8 #foreign libc;
dlopen :: (__path: *u8, __mode: s32) -> *void #foreign libc;
dlsym :: (__handle: *void, __symbol: *u8) -> *void #foreign libc;

dlopen_preflight :: (__path: *u8) -> bool #foreign libc;

ino_t :: u64;

dirent :: struct {
    d_ino:     u64;
    d_seekoff: u64;
    d_reclen:  u16;
    d_namlen:  u16;
    d_type:    DT;
    d_name:    [1024] u8;
}

_telldir :: struct {}

/* structure describing an open directory. */
DIR :: struct {
    __dd_fd:    s32; /* file descriptor associated with directory */
    __dd_loc:   s64; /* offset in current buffer */
    __dd_size:  s64; /* amount of data returned */
    __dd_buf:   *u8; /* data buffer */
    __dd_len:   s32; /* size of data buffer */
    __dd_seek:  s64; /* magic cookie returned */
    __padding:  s64; /* (__dd_rewind space left for bincompat) */
    __dd_flags: s32; /* flags for readdir */
    __dd_lock:  _opaque_pthread_mutex_t; /* for thread locking */
    __dd_td:    *_telldir; /* telldir position recording */
}

closedir :: (unknown0: *DIR) -> s32 #foreign libc;

opendir :: (unknown0: *u8) -> *DIR #foreign libc;

readdir :: (unknown0: *DIR) -> *dirent #foreign libc;
readdir_r :: (unknown0: *DIR, unknown1: *dirent, unknown2: **dirent) -> s32 #foreign libc;

rewinddir :: (unknown0: *DIR) -> void #foreign libc;

seekdir :: (unknown0: *DIR, unknown1: s64) -> void #foreign libc;

telldir :: (unknown0: *DIR) -> s64 #foreign libc;

fdopendir :: (unknown0: s32) -> *DIR #foreign libc;

alphasort :: (unknown0: **dirent, unknown1: **dirent) -> s32 #foreign libc;

dirfd :: (dirp: *DIR) -> s32 #foreign libc;

scandir :: (unknown0: *u8, unknown1: ***dirent, unknown2: #type (unknown0: *dirent) -> s32 #c_call, unknown3: #type (unknown0: **dirent, unknown1: **dirent) -> s32 #c_call) -> s32 #foreign libc;

__opendir2 :: (unknown0: *u8, unknown1: s32) -> *DIR #foreign libc;

__errno_location :: () -> *OS_Error_Code #foreign libc "__error";

uuid_t :: [16] u8;

backtrace :: (unknown0: **void, unknown1: s32) -> s32 #foreign libc;

backtrace_from_fp :: (startfp: *void, array: **void, size: s32) -> s32 #foreign libc;

backtrace_symbols :: (unknown0: **void, unknown1: s32) -> **u8 #foreign libc;
backtrace_symbols_fd :: (unknown0: **void, unknown1: s32, unknown2: s32) -> void #foreign libc;

image_offset :: struct {
    /*
    * The UUID of the image.
    */
    uuid:   uuid_t;

    /*
    * The offset is relative to the __TEXT section of the image.
    */
    offset: u32;
}

backtrace_image_offsets :: (array: **void, image_offsets: *image_offset, size: s32) -> void #foreign libc;

fnmatch :: (unknown0: *u8, unknown1: *u8, unknown2: s32) -> s32 #foreign libc;

gid_t :: u32;

uid_t :: u32;

passwd :: struct {
    pw_name:   *u8; /* user name */
    pw_passwd: *u8; /* encrypted password */
    pw_uid:    uid_t; /* user uid */
    pw_gid:    gid_t; /* user gid */
    pw_change: s64; /* password change time */
    pw_class:  *u8; /* user access class */
    pw_gecos:  *u8; /* Honeywell login info */
    pw_dir:    *u8; /* home directory */
    pw_shell:  *u8; /* default shell */
    pw_expire: s64; /* account expiration */
}

getpwuid :: (unknown0: uid_t) -> *passwd #foreign libc;
getpwnam :: (unknown0: *u8) -> *passwd #foreign libc;
getpwuid_r :: (unknown0: uid_t, unknown1: *passwd, unknown2: *u8, unknown3: u64, unknown4: **passwd) -> s32 #foreign libc;
getpwnam_r :: (unknown0: *u8, unknown1: *passwd, unknown2: *u8, unknown3: u64, unknown4: **passwd) -> s32 #foreign libc;
getpwent :: () -> *passwd #foreign libc;
setpwent :: () -> void #foreign libc;
endpwent :: () -> void #foreign libc;

setpassent :: (unknown0: s32) -> s32 #foreign libc;
user_from_uid :: (unknown0: uid_t, unknown1: s32) -> *u8 #foreign libc;
getpwuuid :: (unknown0: *uuid_t) -> *passwd #foreign libc;
getpwuuid_r :: (unknown0: *uuid_t, unknown1: *passwd, unknown2: *u8, unknown3: u64, unknown4: **passwd) -> s32 #foreign libc;

sig_atomic_t :: s32;

__darwin_arm_exception_state :: struct {
    __exception: u32;
    __fsr:       u32;
    __far:       u32;
}

__darwin_arm_exception_state64 :: struct {
    __far:       u64;
    __esr:       u32;
    __exception: u32;
}

__darwin_arm_thread_state :: struct {
    __r:    [13] u32;
    __sp:   u32;
    __lr:   u32;
    __pc:   u32;
    __cpsr: u32;
}

__darwin_arm_thread_state64 :: struct {
    __x:    [29] u64;
    __fp:   u64;
    __lr:   u64;
    __sp:   u64;
    __pc:   u64;
    __cpsr: u32;
    __pad:  u32;
}

__darwin_arm_vfp_state :: struct {
    __r:     [64] u32;
    __fpscr: u32;
}

__darwin_arm_neon_state64 :: struct {
    __v:    [32] U128;
    __fpsr: u32;
    __fpcr: u32;
}

__darwin_arm_neon_state :: struct {
    __v:    [16] U128;
    __fpsr: u32;
    __fpcr: u32;
}

__darwin_arm_amx_state_v1 :: struct {
    __x:               [8] [64] u8;
    __y:               [8] [64] u8;
    __z:               [64] [64] u8;
    __amx_state_t_el1: u64;
}

__arm_pagein_state :: struct {
    __pagein_error: s32;
}

__arm_legacy_debug_state :: struct {
    __bvr: [16] u32;
    __bcr: [16] u32;
    __wvr: [16] u32;
    __wcr: [16] u32;
}

__darwin_arm_debug_state32 :: struct {
    __bvr:       [16] u32;
    __bcr:       [16] u32;
    __wvr:       [16] u32;
    __wcr:       [16] u32;
    __mdscr_el1: u64;
}

__darwin_arm_debug_state64 :: struct {
    __bvr:       [16] u64;
    __bcr:       [16] u64;
    __wvr:       [16] u64;
    __wcr:       [16] u64;
    __mdscr_el1: u64;
}

__darwin_arm_cpmu_state64 :: struct {
    __ctrs: [16] u64;
}

__darwin_mcontext64 :: struct {
    __es: __darwin_arm_exception_state64;
    __ss: __darwin_arm_thread_state64;
    __ns: __darwin_arm_neon_state64;
}

stack_t :: struct {
    ss_sp:    *void;
    ss_size:  u64;
    ss_flags: s32;
}

ucontext_t :: struct {
    uc_onstack:  s32;
    uc_sigmask:  u32;
    uc_stack:    stack_t;
    uc_link:     *ucontext_t;
    uc_mcsize:   u64;
    uc_mcontext: *__darwin_mcontext64;
}

pid_t :: s32;

sigset_t :: u32;

sigval :: union {
    sival_int: s32;
    sival_ptr: *void;
}

sigevent :: struct {
    sigev_notify:            s32;
    sigev_signo:             s32;
    sigev_value:             sigval;
    sigev_notify_function:   #type (unknown0: sigval) -> void #c_call;
    sigev_notify_attributes: *pthread_attr_t;
}

__siginfo :: struct {
    si_signo:  s32;
    si_errno:  s32;
    si_code:   s32;
    si_pid:    pid_t;
    si_uid:    uid_t;
    si_status: s32;
    si_addr:   *void;
    si_value:  sigval;
    si_band:   s64;
    __pad:     [7] u64;
}

siginfo_t :: __siginfo;

__sigaction_u :: union {
    sa_handler:   #type (unknown0: s32) -> void #c_call;
    sa_sigaction: #type (unknown0: s32, unknown1: *__siginfo, unknown2: *void) -> void #c_call;
}

__sigaction :: struct {
    using __sigaction_u_: __sigaction_u;
    sa_tramp:       #type (unknown0: *void, unknown1: s32, unknown2: s32, unknown3: *siginfo_t, unknown4: *void) -> void #c_call;
    sa_mask:        sigset_t;
    sa_flags:       s32;
}

sigaction_t :: struct {
    using __sigaction_u_: __sigaction_u;
    sa_mask:        sigset_t;
    sa_flags:       s32;
}

sig_t :: #type (unknown0: s32) -> void #c_call;

sigvec :: struct {
    sv_handler: #type (unknown0: s32) -> void #c_call;
    sv_mask:    s32;
    sv_flags:   s32;
}

signal :: (unknown0: s32, unknown1: s32, unknown2: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32, unknown1: s32, unknown2: ((unknown0: s32) -> void #c_call)) -> void #c_call) #foreign libc;

raise :: (unknown0: s32) -> s32 #foreign libc;

bsd_signal :: (unknown0: s32, unknown1: s32, unknown2: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32, unknown1: s32, unknown2: ((unknown0: s32) -> void #c_call)) -> void #c_call) #foreign libc;
kill :: (unknown0: pid_t, unknown1: s32) -> s32 #foreign libc;
killpg :: (unknown0: pid_t, unknown1: s32) -> s32 #foreign libc;

sigaction :: (unknown0: s32, unknown1: *sigaction_t, unknown2: *sigaction_t) -> s32 #foreign libc;

sigaddset :: (unknown0: *sigset_t, unknown1: s32) -> s32 #foreign libc;
sigaltstack :: (unknown0: *stack_t, unknown1: *stack_t) -> s32 #foreign libc;
sigdelset :: (unknown0: *sigset_t, unknown1: s32) -> s32 #foreign libc;
sigemptyset :: (unknown0: *sigset_t) -> s32 #foreign libc;
sigfillset :: (unknown0: *sigset_t) -> s32 #foreign libc;
sighold :: (unknown0: s32) -> s32 #foreign libc;
sigignore :: (unknown0: s32) -> s32 #foreign libc;
siginterrupt :: (unknown0: s32, unknown1: s32) -> s32 #foreign libc;
sigismember :: (unknown0: *sigset_t, unknown1: s32) -> s32 #foreign libc;
sigpause :: (unknown0: s32) -> s32 #foreign libc;
sigpending :: (unknown0: *sigset_t) -> s32 #foreign libc;
sigprocmask :: (unknown0: s32, unknown1: *sigset_t, unknown2: *sigset_t) -> s32 #foreign libc;
sigrelse :: (unknown0: s32) -> s32 #foreign libc;
sigset :: (unknown0: s32, unknown1: s32, unknown2: #type (unknown0: s32) -> void #c_call) -> ((unknown0: s32, unknown1: s32, unknown2: ((unknown0: s32) -> void #c_call)) -> void #c_call) #foreign libc;
sigsuspend :: (unknown0: *sigset_t) -> s32 #foreign libc;
sigwait :: (unknown0: *sigset_t, unknown1: *s32) -> s32 #foreign libc;

psignal :: (unknown0: u32, unknown1: *u8) -> void #foreign libc;
sigblock :: (unknown0: s32) -> s32 #foreign libc;
sigsetmask :: (unknown0: s32) -> s32 #foreign libc;
sigvec_ :: (unknown0: s32, unknown1: *sigvec, unknown2: *sigvec) -> s32 #foreign libc "sigvec";

mode_t :: u16;

key_t :: s32;

/*
* [XSI] Information used in determining permission to perform an IPC
* operation
*/
ipc_perm :: struct {
    uid:  uid_t; /* [XSI] Owner's user ID */
    gid:  gid_t; /* [XSI] Owner's group ID */
    cuid: uid_t; /* [XSI] Creator's user ID */
    cgid: gid_t; /* [XSI] Creator's group ID */
    mode: mode_t; /* [XSI] Read/write permission */
    _seq: u16; /* Reserved for internal use */
    _key: key_t; /* Reserved for internal use */
}

/* [XSI] */
ftok :: (unknown0: *u8, unknown1: s32) -> key_t #foreign libc;

/* [ML] */
mlockall :: (unknown0: s32) -> s32 #foreign libc;
munlockall :: () -> s32 #foreign libc;

/* [MR] */
mlock :: (unknown0: *void, unknown1: u64) -> s32 #foreign libc;

/* [MC3]*/
mmap :: (unknown0: *void, unknown1: u64, unknown2: s32, unknown3: s32, unknown4: s32, unknown5: s64) -> *void #foreign libc;

/* [MPR] */
mprotect :: (unknown0: *void, unknown1: u64, unknown2: s32) -> s32 #foreign libc;

/* [MF|SIO] */
msync :: (unknown0: *void, unknown1: u64, unknown2: s32) -> s32 #foreign libc;

/* [MR] */
munlock :: (unknown0: *void, unknown1: u64) -> s32 #foreign libc;

/* [MC3]*/
munmap :: (unknown0: *void, unknown1: u64) -> s32 #foreign libc;

/* [SHM] */
shm_open :: (unknown0: *u8, unknown1: s32, __args: ..Any) -> s32 #foreign libc;
shm_unlink :: (unknown0: *u8) -> s32 #foreign libc;

/* [ADV] */
posix_madvise :: (unknown0: *void, unknown1: u64, unknown2: s32) -> s32 #foreign libc;

madvise :: (unknown0: *void, unknown1: u64, unknown2: s32) -> s32 #foreign libc;
mincore :: (unknown0: *void, unknown1: u64, unknown2: *u8) -> s32 #foreign libc;
minherit :: (unknown0: *void, unknown1: u64, unknown2: s32) -> s32 #foreign libc;

pollfd :: struct {
    fd:      s32;
    events:  s16;
    revents: s16;
}

nfds_t :: u32;

/*
* This is defined here (instead of <poll.h>) because this is where
* traditional SVR4 code will look to find it.
*/
poll :: (unknown0: *pollfd, unknown1: nfds_t, unknown2: s32) -> s32 #foreign libc;

time_t :: s64;

/*
* [XSI] The unsigned integer type used for the number of current attaches
* that MUST be able to store values at least as large as a type unsigned
* short.
*/
shmatt_t :: u16;

__shmid_ds_new :: struct {
    shm_perm:     ipc_perm; /* [XSI] Operation permission value */
    shm_segsz:    u64; /* [XSI] Size of segment in bytes */
    shm_lpid:     pid_t; /* [XSI] PID of last shared memory op */
    shm_cpid:     pid_t; /* [XSI] PID of creator */
    shm_nattch:   shmatt_t; /* [XSI] Number of current attaches */
    shm_atime:    time_t #align 4; /* [XSI] Time of last shmat() */
    shm_dtime:    time_t #align 4; /* [XSI] Time of last shmdt() */
    shm_ctime:    time_t #align 4; /* [XSI] Time of last shmctl() change */
    shm_internal: *void #align 4; /* reserved for kernel use */
}

shmsys :: (unknown0: s32, __args: ..Any) -> s32 #foreign libc;

shmat :: (unknown0: s32, unknown1: *void, unknown2: s32) -> *void #foreign libc;
shmctl :: (unknown0: s32, unknown1: s32, unknown2: *__shmid_ds_new) -> s32 #foreign libc;
shmdt :: (unknown0: *void) -> s32 #foreign libc;
shmget :: (unknown0: key_t, unknown1: u64, unknown2: s32) -> s32 #foreign libc;

timespec :: struct {
    tv_sec:  s64;
    tv_nsec: s64;
}

timeval :: struct {
    tv_sec:  s64;
    tv_usec: s32;
}

suseconds_t :: s32;

/*
* Structure used as a parameter by getitimer(2) and setitimer(2) system
* calls.
*/
itimerval :: struct {
    it_interval: timeval; /* timer interval */
    it_value:    timeval; /* current value */
}

timezone :: struct {
    tz_minuteswest: s32; /* minutes west of Greenwich */
    tz_dsttime:     s32; /* type of dst correction */
}

/*
* Getkerninfo clock information structure
*/
clockinfo :: struct {
    hz:      s32; /* clock frequency */
    tick:    s32; /* micro-seconds per hz tick */
    tickadj: s32; /* clock skew rate for adjtime() */
    stathz:  s32; /* statistics clock frequency */
    profhz:  s32; /* profiling clock frequency */
}

clock_t :: u64;

tm :: struct {
    tm_sec:    s32;
    tm_min:    s32;
    tm_hour:   s32;
    tm_mday:   s32;
    tm_mon:    s32;
    tm_year:   s32;
    tm_wday:   s32;
    tm_yday:   s32;
    tm_isdst:  s32;
    tm_gmtoff: s64;
    tm_zone:   *u8;
}

tzname: **u8 #elsewhere libc;

getdate_err: s32 #elsewhere libc;

daylight: s32 #elsewhere libc;

asctime :: (unknown0: *tm) -> *u8 #foreign libc;
clock :: () -> clock_t #foreign libc;
ctime :: (unknown0: *time_t) -> *u8 #foreign libc;
difftime :: (unknown0: time_t, unknown1: time_t) -> float64 #foreign libc;
getdate :: (unknown0: *u8) -> *tm #foreign libc;
gmtime :: (unknown0: *time_t) -> *tm #foreign libc;
localtime :: (unknown0: *time_t) -> *tm #foreign libc;
mktime :: (unknown0: *tm) -> time_t #foreign libc;
strftime :: (unknown0: *u8, unknown1: u64, unknown2: *u8, unknown3: *tm) -> u64 #foreign libc;
strptime :: (unknown0: *u8, unknown1: *u8, unknown2: *tm) -> *u8 #foreign libc;
time :: (unknown0: *time_t) -> time_t #foreign libc;

tzset :: () -> void #foreign libc;

asctime_r :: (unknown0: *tm, unknown1: *u8) -> *u8 #foreign libc;
ctime_r :: (unknown0: *time_t, unknown1: *u8) -> *u8 #foreign libc;
gmtime_r :: (unknown0: *time_t, unknown1: *tm) -> *tm #foreign libc;
localtime_r :: (unknown0: *time_t, unknown1: *tm) -> *tm #foreign libc;

posix2time :: (unknown0: time_t) -> time_t #foreign libc;

tzsetwall :: () -> void #foreign libc;
time2posix :: (unknown0: time_t) -> time_t #foreign libc;
timelocal :: (unknown0: *tm) -> time_t #foreign libc;
timegm :: (unknown0: *tm) -> time_t #foreign libc;

nanosleep :: (__rqtp: *timespec, __rmtp: *timespec) -> s32 #foreign libc;

clockid_t :: enum u32 {
    REALTIME             :: 0;

    MONOTONIC            :: 6;

    MONOTONIC_RAW        :: 4;

    MONOTONIC_RAW_APPROX :: 5;

    UPTIME_RAW           :: 8;

    UPTIME_RAW_APPROX    :: 9;

    PROCESS_CPUTIME_ID   :: 12;

    THREAD_CPUTIME_ID    :: 16;

    _CLOCK_REALTIME             :: REALTIME;

    _CLOCK_MONOTONIC            :: MONOTONIC;

    _CLOCK_MONOTONIC_RAW        :: MONOTONIC_RAW;

    _CLOCK_MONOTONIC_RAW_APPROX :: MONOTONIC_RAW_APPROX;

    _CLOCK_UPTIME_RAW           :: UPTIME_RAW;

    _CLOCK_UPTIME_RAW_APPROX    :: UPTIME_RAW_APPROX;

    _CLOCK_PROCESS_CPUTIME_ID   :: PROCESS_CPUTIME_ID;

    _CLOCK_THREAD_CPUTIME_ID    :: THREAD_CPUTIME_ID;
}

clock_getres :: (__clock_id: clockid_t, __res: *timespec) -> s32 #foreign libc;

clock_gettime :: (__clock_id: clockid_t, __tp: *timespec) -> s32 #foreign libc;

clock_gettime_nsec_np :: (__clock_id: clockid_t) -> u64 #foreign libc;

clock_settime :: (__clock_id: clockid_t, __tp: *timespec) -> s32 #foreign libc;

timespec_get :: (ts: *timespec, base: s32) -> s32 #foreign libc;

adjtime :: (unknown0: *timeval, unknown1: *timeval) -> s32 #foreign libc;
futimes :: (unknown0: s32, unknown1: *timeval) -> s32 #foreign libc;
lutimes :: (unknown0: *u8, unknown1: *timeval) -> s32 #foreign libc;
settimeofday :: (unknown0: *timeval, unknown1: *timezone) -> s32 #foreign libc;

getitimer :: (unknown0: s32, unknown1: *itimerval) -> s32 #foreign libc;
gettimeofday :: (unknown0: *timeval, unknown1: *void) -> s32 #foreign libc;

setitimer :: (unknown0: s32, unknown1: *itimerval, unknown2: *itimerval) -> s32 #foreign libc;

utimes :: (unknown0: *u8, unknown1: *timeval) -> s32 #foreign libc;

dev_t :: s32;

fixpt_t :: u32;

blkcnt_t :: s64;

blksize_t :: s32;

nlink_t :: u16;

segsz_t :: s32;

useconds_t :: u32;

utsname :: struct {
    sysname:  [256] u8; /* [XSI] Name of OS */
    nodename: [256] u8; /* [XSI] Name of this network node */
    release:  [256] u8; /* [XSI] Release level */
    version:  [256] u8; /* [XSI] Version level */
    machine:  [256] u8; /* [XSI] Hardware type */
}

uname :: (unknown0: *utsname) -> s32 #foreign libc;

/*
* [XSI] The type idtype_t shall be defined as an enumeration type whose
* possible values shall include at least P_ALL, P_PID, and P_PGID.
*/
idtype_t :: enum u32 {
    ALL  :: 0;
    PID  :: 1;
    PGID :: 2;

    P_ALL  :: ALL;
    P_PID  :: PID;
    P_PGID :: PGID;
}

/*
* Deprecated:
* Structure of the information in the status word returned by wait4.
* If w_stopval==_WSTOPPED, then the second structure describes
* the information returned, else the first.
*/
wait_t :: union {
    w_status: s32; /* used in syscall */

    w_T:      struct {
        w_Termsig:  u32; /* termination signal */
        #place w_Termsig; /*bitfield 7*/ w_Coredump: u32; /* core dump indicator */
        #place w_Termsig; /*bitfield 8*/ w_Retcode:  u32; /* exit code if w_termsig==0 */
        #place w_Termsig; /*bitfield 16*/ w_Filler:   u32; /* upper bits filler */
    };

    w_S:      struct {
        w_Stopval: u32; /* == W_STOPPED if stopped */
        #place w_Stopval; /*bitfield 8*/ w_Stopsig: u32; /* signal that stopped us */
        #place w_Stopval; /*bitfield 16*/ w_Filler:  u32; /* upper bits filler */
    };
}

wait :: (unknown0: *s32) -> pid_t #foreign libc;
waitpid :: (unknown0: pid_t, unknown1: *s32, unknown2: s32) -> pid_t #foreign libc;

waitid :: (unknown0: idtype_t, unknown1: id_t, unknown2: *siginfo_t, unknown3: s32) -> s32 #foreign libc;

wait3 :: (unknown0: *s32, unknown1: s32, unknown2: *rusage) -> pid_t #foreign libc;
wait4 :: (unknown0: pid_t, unknown1: *s32, unknown2: s32, unknown3: *rusage) -> pid_t #foreign libc;

accessx_descriptor :: struct {
    ad_name_offset: u32;
    ad_flags:       s32;
    ad_pad:         [2] s32;
}

getattrlistbulk :: (unknown0: s32, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: u64) -> s32 #foreign libc;
getattrlistat :: (unknown0: s32, unknown1: *u8, unknown2: *void, unknown3: *void, unknown4: u64, unknown5: u64) -> s32 #foreign libc;
setattrlistat :: (unknown0: s32, unknown1: *u8, unknown2: *void, unknown3: *void, unknown4: u64, unknown5: u32) -> s32 #foreign libc;

faccessat :: (unknown0: s32, unknown1: *u8, unknown2: s32, unknown3: s32) -> s32 #foreign libc;
fchownat :: (unknown0: s32, unknown1: *u8, unknown2: uid_t, unknown3: gid_t, unknown4: s32) -> s32 #foreign libc;
linkat :: (unknown0: s32, unknown1: *u8, unknown2: s32, unknown3: *u8, unknown4: s32) -> s32 #foreign libc;
readlinkat :: (unknown0: s32, unknown1: *u8, unknown2: *u8, unknown3: u64) -> s64 #foreign libc;
symlinkat :: (unknown0: *u8, unknown1: s32, unknown2: *u8) -> s32 #foreign libc;
unlinkat :: (unknown0: s32, unknown1: *u8, unknown2: s32) -> s32 #foreign libc;

/* POSIX.1-1990 */
_exit :: (unknown0: s32) -> void #foreign libc;
access :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;

alarm :: (unknown0: u32) -> u32 #foreign libc;
chdir :: (unknown0: *u8) -> s32 #foreign libc;
chown :: (unknown0: *u8, unknown1: uid_t, unknown2: gid_t) -> s32 #foreign libc;

close :: (unknown0: s32) -> s32 #foreign libc;

dup :: (unknown0: s32) -> s32 #foreign libc;
dup2 :: (unknown0: s32, unknown1: s32) -> s32 #foreign libc;
execl :: (__path: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;
execle :: (__path: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;
execlp :: (__file: *u8, __arg0: *u8, __args: ..Any) -> s32 #foreign libc;
execv :: (__path: *u8, __argv: **u8) -> s32 #foreign libc;
execve :: (__file: *u8, __argv: **u8, __envp: **u8) -> s32 #foreign libc;
execvp :: (__file: *u8, __argv: **u8) -> s32 #foreign libc;
fork :: () -> pid_t #foreign libc;
fpathconf :: (unknown0: s32, __name: PC) -> s64 #foreign libc;
getcwd :: (unknown0: *u8, unknown1: u64) -> *u8 #foreign libc;
getegid :: () -> gid_t #foreign libc;
geteuid :: () -> uid_t #foreign libc;
getgid :: () -> gid_t #foreign libc;

getgroups :: (unknown0: s32, unknown1: *gid_t) -> s32 #foreign libc;

getlogin :: () -> *u8 #foreign libc;
getpgrp :: () -> pid_t #foreign libc;
getpid :: () -> pid_t #foreign libc;
getppid :: () -> pid_t #foreign libc;
getuid :: () -> uid_t #foreign libc;
isatty :: (unknown0: s32) -> s32 #foreign libc;
link :: (unknown0: *u8, unknown1: *u8) -> s32 #foreign libc;
lseek :: (unknown0: s32, unknown1: s64, unknown2: s32) -> s64 #foreign libc;
pathconf :: (unknown0: *u8, __name: PC) -> s64 #foreign libc;

pause :: () -> s32 #foreign libc;

pipe :: (unknown0: *[2] s32) -> s32 #foreign libc;

read :: (unknown0: s32, unknown1: *void, unknown2: u64) -> s64 #foreign libc;

rmdir :: (unknown0: *u8) -> s32 #foreign libc;
setgid :: (unknown0: gid_t) -> s32 #foreign libc;
setpgid :: (unknown0: pid_t, unknown1: pid_t) -> s32 #foreign libc;
setsid :: () -> pid_t #foreign libc;
setuid :: (unknown0: uid_t) -> s32 #foreign libc;

sleep :: (unknown0: u32) -> u32 #foreign libc;

sysconf :: (name: _SC_definitions) -> s64 #foreign libc;
tcgetpgrp :: (unknown0: s32) -> pid_t #foreign libc;
tcsetpgrp :: (unknown0: s32, unknown1: pid_t) -> s32 #foreign libc;
ttyname :: (unknown0: s32) -> *u8 #foreign libc;

ttyname_r :: (unknown0: s32, unknown1: *u8, unknown2: u64) -> s32 #foreign libc;

unlink :: (unknown0: *u8) -> s32 #foreign libc;

write :: (__fd: s32, __buf: *void, __nbyte: u64) -> s64 #foreign libc;

confstr :: (unknown0: s32, unknown1: *u8, unknown2: u64) -> u64 #foreign libc;

getopt :: (unknown0: s32, unknown1: **u8, unknown2: *u8) -> s32 #foreign libc;

optarg: *u8 #elsewhere libc; /* getopt(3) external variables */
optind: s32 #elsewhere libc;
opterr: s32 #elsewhere libc;
optopt: s32 #elsewhere libc;

brk :: (unknown0: *void) -> *void #foreign libc;
chroot :: (unknown0: *u8) -> s32 #foreign libc;

crypt :: (unknown0: *u8, unknown1: *u8) -> *u8 #foreign libc;

encrypt :: (unknown0: *u8, unknown1: s32) -> void #foreign libc;

fchdir :: (unknown0: s32) -> s32 #foreign libc;
gethostid :: () -> s64 #foreign libc;
getpgid :: (unknown0: pid_t) -> pid_t #foreign libc;
getsid :: (unknown0: pid_t) -> pid_t #foreign libc;

getdtablesize :: () -> s32 #foreign libc;
getpagesize :: () -> s32 #foreign libc;
getpass :: (unknown0: *u8) -> *u8 #foreign libc;

getwd :: (unknown0: *u8) -> *u8 #foreign libc;

lchown :: (unknown0: *u8, unknown1: uid_t, unknown2: gid_t) -> s32 #foreign libc;

lockf :: (unknown0: s32, unknown1: s32, unknown2: s64) -> s32 #foreign libc;

nice :: (unknown0: s32) -> s32 #foreign libc;

pread :: (__fd: s32, __buf: *void, __nbyte: u64, __offset: s64) -> s64 #foreign libc;

pwrite :: (__fd: s32, __buf: *void, __nbyte: u64, __offset: s64) -> s64 #foreign libc;

sbrk :: (unknown0: s32) -> *void #foreign libc;

setpgrp :: () -> pid_t #foreign libc;

setregid :: (unknown0: gid_t, unknown1: gid_t) -> s32 #foreign libc;

setreuid :: (unknown0: uid_t, unknown1: uid_t) -> s32 #foreign libc;

swab :: (unknown0: *void, unknown1: *void, unknown2: s64) -> void #foreign libc;
sync :: () -> void #foreign libc;
truncate :: (unknown0: *u8, unknown1: s64) -> s32 #foreign libc;
ualarm :: (unknown0: useconds_t, unknown1: useconds_t) -> useconds_t #foreign libc;
usleep :: (unknown0: useconds_t) -> s32 #foreign libc;
vfork :: () -> s32 #foreign libc;

/* End XSI */
fsync :: (unknown0: s32) -> s32 #foreign libc;

ftruncate :: (unknown0: s32, unknown1: s64) -> s32 #foreign libc;
getlogin_r :: (unknown0: *u8, unknown1: u64) -> s32 #foreign libc;

fchown :: (unknown0: s32, unknown1: uid_t, unknown2: gid_t) -> s32 #foreign libc;
gethostname :: (unknown0: *u8, unknown1: u64) -> s32 #foreign libc;
readlink :: (unknown0: *u8, unknown1: *u8, unknown2: u64) -> s64 #foreign libc;
setegid :: (unknown0: gid_t) -> s32 #foreign libc;
seteuid :: (unknown0: uid_t) -> s32 #foreign libc;
symlink :: (unknown0: *u8, unknown1: *u8) -> s32 #foreign libc;

_Exit :: (unknown0: s32) -> void #foreign libc;

acct :: (unknown0: *u8) -> s32 #foreign libc;

endusershell :: () -> void #foreign libc;
execvP :: (__file: *u8, __searchpath: *u8, __argv: **u8) -> s32 #foreign libc;
fflagstostr :: (unknown0: u64) -> *u8 #foreign libc;
getdomainname :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;
getgrouplist :: (unknown0: *u8, unknown1: s32, unknown2: *s32, unknown3: *s32) -> s32 #foreign libc;

getmode :: (unknown0: *void, unknown1: mode_t) -> mode_t #foreign libc;
getpeereid :: (unknown0: s32, unknown1: *uid_t, unknown2: *gid_t) -> s32 #foreign libc;
getsgroups_np :: (unknown0: *s32, unknown1: *uuid_t) -> s32 #foreign libc;
getusershell :: () -> *u8 #foreign libc;
getwgroups_np :: (unknown0: *s32, unknown1: *uuid_t) -> s32 #foreign libc;
initgroups :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;
issetugid :: () -> s32 #foreign libc;

nfssvc :: (unknown0: s32, unknown1: *void) -> s32 #foreign libc;

reboot :: (unknown0: s32) -> s32 #foreign libc;
revoke :: (unknown0: *u8) -> s32 #foreign libc;

rcmd :: (unknown0: **u8, unknown1: s32, unknown2: *u8, unknown3: *u8, unknown4: *u8, unknown5: *s32) -> s32 #foreign libc;
rcmd_af :: (unknown0: **u8, unknown1: s32, unknown2: *u8, unknown3: *u8, unknown4: *u8, unknown5: *s32, unknown6: s32) -> s32 #foreign libc;

rresvport :: (unknown0: *s32) -> s32 #foreign libc;
rresvport_af :: (unknown0: *s32, unknown1: s32) -> s32 #foreign libc;
iruserok :: (unknown0: u64, unknown1: s32, unknown2: *u8, unknown3: *u8) -> s32 #foreign libc;
iruserok_sa :: (unknown0: *void, unknown1: s32, unknown2: s32, unknown3: *u8, unknown4: *u8) -> s32 #foreign libc;
ruserok :: (unknown0: *u8, unknown1: s32, unknown2: *u8, unknown3: *u8) -> s32 #foreign libc;

setdomainname :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;
setgroups :: (unknown0: s32, unknown1: *gid_t) -> s32 #foreign libc;
sethostid :: (unknown0: s64) -> void #foreign libc;
sethostname :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;

setkey :: (unknown0: *u8) -> void #foreign libc;

setlogin :: (unknown0: *u8) -> s32 #foreign libc;
setmode :: (unknown0: *u8) -> *void #foreign libc;
setrgid :: (unknown0: gid_t) -> s32 #foreign libc;
setruid :: (unknown0: uid_t) -> s32 #foreign libc;
setsgroups_np :: (unknown0: s32, unknown1: *uuid_t) -> s32 #foreign libc;
setusershell :: () -> void #foreign libc;
setwgroups_np :: (unknown0: s32, unknown1: *uuid_t) -> s32 #foreign libc;
strtofflags :: (unknown0: **u8, unknown1: *u64, unknown2: *u64) -> s32 #foreign libc;
swapon :: (unknown0: *u8) -> s32 #foreign libc;
ttyslot :: () -> s32 #foreign libc;
undelete :: (unknown0: *u8) -> s32 #foreign libc;

valloc :: (unknown0: u64) -> *void #foreign libc;

suboptarg: *u8 #elsewhere libc; /* getsubopt(3) external variable */
getsubopt :: (unknown0: **u8, unknown1: **u8, unknown2: **u8) -> s32 #foreign libc;

fgetattrlist :: (unknown0: s32, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: u32) -> s32 #foreign libc;
fsetattrlist :: (unknown0: s32, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: u32) -> s32 #foreign libc;
getattrlist :: (unknown0: *u8, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: u32) -> s32 #foreign libc;
setattrlist :: (unknown0: *u8, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: u32) -> s32 #foreign libc;
exchangedata :: (unknown0: *u8, unknown1: *u8, unknown2: u32) -> s32 #foreign libc;
getdirentriesattr :: (unknown0: s32, unknown1: *void, unknown2: *void, unknown3: u64, unknown4: *u32, unknown5: *u32, unknown6: *u32, unknown7: u32) -> s32 #foreign libc;

searchfs :: (unknown0: *u8, unknown1: *fssearchblock, unknown2: *u64, unknown3: u32, unknown4: u32, unknown5: *searchstate) -> s32 #foreign libc;
fsctl :: (unknown0: *u8, unknown1: u64, unknown2: *void, unknown3: u32) -> s32 #foreign libc;
ffsctl :: (unknown0: s32, unknown1: u64, unknown2: *void, unknown3: u32) -> s32 #foreign libc;

fsync_volume_np :: (unknown0: s32, unknown1: s32) -> s32 #foreign libc;
sync_volume_np :: (unknown0: *u8, unknown1: s32) -> s32 #foreign libc;

optreset: s32 #elsewhere libc;

mach_port_t :: u32;

text_encoding_t :: u32;

fsobj_type_t :: u32;

fsobj_tag_t :: u32;

fsfile_type_t :: u32;

fsvolid_t :: u32;

attrgroup_t :: u32;

attrlist :: struct {
    bitmapcount: u16; /* number of attr. bit sets in list (should be 5) */
    reserved:    u16; /* (to maintain 4-byte alignment) */
    commonattr:  ATTR_CMN; /* common attribute group */
    volattr:     attrgroup_t; /* Volume attribute group */
    dirattr:     attrgroup_t; /* directory attribute group */
    fileattr:    attrgroup_t; /* file attribute group */
    forkattr:    attrgroup_t; /* fork attribute group */
}

attribute_set :: struct {
    commonattr: ATTR_CMN; /* common attribute group */
    volattr:    attrgroup_t; /* Volume attribute group */
    dirattr:    attrgroup_t; /* directory attribute group */
    fileattr:   attrgroup_t; /* file attribute group */
    forkattr:   attrgroup_t; /* fork attribute group */
}

attribute_set_t :: attribute_set;

attrreference :: struct {
    attr_dataoffset: s32;
    attr_length:     u32;
}

attrreference_t :: attrreference;

/* XXX PPD This is derived from HFSVolumePriv.h and should perhaps be referenced from there? */
diskextent :: struct {
    startblock: u32; /* first block allocated */
    blockcount: u32; /* number of blocks allocated */
}

extentrecord :: [8] diskextent;

vol_capabilities_set_t :: [4] u32;

vol_capabilities_attr :: struct {
    capabilities: vol_capabilities_set_t;
    valid:        vol_capabilities_set_t;
}

vol_capabilities_attr_t :: vol_capabilities_attr;

vol_attributes_attr :: struct {
    validattr:  attribute_set_t;
    nativeattr: attribute_set_t;
}

vol_attributes_attr_t :: vol_attributes_attr;

fssearchblock :: struct {
    returnattrs:         *attrlist;
    returnbuffer:        *void;
    returnbuffersize:    u64;
    maxmatches:          u64;
    timelimit:           timeval;
    searchparams1:       *void;
    sizeofsearchparams1: u64;
    searchparams2:       *void;
    sizeofsearchparams2: u64;
    searchattrs:         attrlist;
}

searchstate :: struct {
    ss_union_flags: u32; // for SRCHFS_START
    ss_union_layer: u32; // 0 = top
    ss_fsstate:     [548] u8; // fs private
}

iovec :: struct {
    iov_base: *void; /* [XSI] Base address of I/O memory region */
    iov_len:  u64; /* [XSI] Size of region iov_base points to */
}

/*
* Vnode types.  VNON means no type.
*/
vtype :: enum u32 {
    NON  :: 0;

    REG  :: 1;
    DIR  :: 2;
    BLK  :: 3;
    CHR  :: 4;
    LNK  :: 5;

    SOCK :: 6;
    FIFO :: 7;
    BAD  :: 8;
    STR  :: 9;
    CPLX :: 10;

    VNON  :: NON;

    VREG  :: REG;
    VDIR  :: DIR;
    VBLK  :: BLK;
    VCHR  :: CHR;
    VLNK  :: LNK;

    VSOCK :: SOCK;
    VFIFO :: FIFO;
    VBAD  :: BAD;
    VSTR  :: STR;
    VCPLX :: CPLX;
}

/*
* Vnode tag types.
* These are for the benefit of external programs only (e.g., pstat)
* and should NEVER be inspected by the kernel.
*/
vtagtype :: enum u32 {
    NON      :: 0;

    UFS      :: 1;

    NFS      :: 2;
    MFS      :: 3;
    MSDOSFS  :: 4;
    LFS      :: 5;

    LOFS     :: 6;
    FDESC    :: 7;
    PORTAL   :: 8;
    NULL     :: 9;
    UMAP     :: 10;

    KERNFS   :: 11;
    PROCFS   :: 12;
    AFS      :: 13;
    ISOFS    :: 14;
    MOCKFS   :: 15;

    HFS      :: 16;
    ZFS      :: 17;
    DEVFS    :: 18;
    WEBDAV   :: 19;
    UDF      :: 20;

    AFP      :: 21;
    CDDA     :: 22;
    CIFS     :: 23;
    OTHER    :: 24;
    APFS     :: 25;

    LOCKERFS :: 26;
    BINDFS   :: 27;

    VT_NON      :: NON;

    VT_UFS      :: UFS;

    VT_NFS      :: NFS;
    VT_MFS      :: MFS;
    VT_MSDOSFS  :: MSDOSFS;
    VT_LFS      :: LFS;

    VT_LOFS     :: LOFS;
    VT_FDESC    :: FDESC;
    VT_PORTAL   :: PORTAL;
    VT_NULL     :: NULL;
    VT_UMAP     :: UMAP;

    VT_KERNFS   :: KERNFS;
    VT_PROCFS   :: PROCFS;
    VT_AFS      :: AFS;
    VT_ISOFS    :: ISOFS;
    VT_MOCKFS   :: MOCKFS;

    VT_HFS      :: HFS;
    VT_ZFS      :: ZFS;
    VT_DEVFS    :: DEVFS;
    VT_WEBDAV   :: WEBDAV;
    VT_UDF      :: UDF;

    VT_AFP      :: AFP;
    VT_CDDA     :: CDDA;
    VT_CIFS     :: CIFS;
    VT_OTHER    :: OTHER;
    VT_APFS     :: APFS;

    VT_LOCKERFS :: LOCKERFS;
    VT_BINDFS   :: BINDFS;
}

#scope_file

#import "Basic"; // For U128/S128

libc :: #library,system "libc";
